<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>xi_covutils.distances API documentation</title>
<meta name="description" content="Functions and classes to work with residue distances in proteins structures" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>xi_covutils.distances</code></h1>
</header>
<section id="section-intro">
<p>Functions and classes to work with residue distances in proteins structures</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
  Functions and classes to work with residue distances in proteins structures
&#34;&#34;&#34;

import csv
import operator
import re
from functools import reduce
from itertools import combinations, combinations_with_replacement, product
from typing import Callable, Dict, List, Optional, TextIO, Tuple, TypeVar, Union
from Bio.PDB.Atom import Atom

from Bio.PDB.Model import Model
from Bio.PDB.PDBParser import PDBParser
from Bio.PDB.Residue import Residue
from Bio.PDB.Structure import Structure

from xi_covutils.pdbbank import PDBSource, pdb_structure_from

Chain = str
Position = int
Distance = float
Resname = str
AtomId = str
DistanceElement = Tuple[Chain, Position, Chain, Position, Distance]
DistanceElementLong = Tuple[
  Chain, Position, Resname, AtomId,
  Chain, Position, Resname, AtomId,
  Distance
]
DistanceData = List[DistanceElement]
DistanceDataLong = List[DistanceElementLong]
DistanceDataSH = List[Union[DistanceElement, DistanceElementLong]]

AtomSelector = Callable[[Atom, Atom], bool]

class Distances():
  &#39;&#39;&#39;
  Store and access distance data for residues from a protein structure.
  &#39;&#39;&#39;
  def __init__(
      self,
      dist_data: DistanceData
    ):
    &#34;&#34;&#34;
    Creates a new instance from distance data.

    Args:
      dist_data (DistanceData): Distance data should be a list of tuples of five
        elements: (chain1, pos1, chain2, pos2, distance).
    &#34;&#34;&#34;
    dis:Dict[Tuple[Chain, Position], Dict[Tuple[Chain, Position], float]] = {}
    for ch1, po1, ch2, po2, dist in dist_data:
      if (ch1, po1) not in dis:
        dis[(ch1, po1)] = {}
      dis[(ch1, po1)][(ch2, po2)] = dist
    self._distances = dis

  def raw_distances(self) -&gt; DistanceData:
    &#34;&#34;&#34;
    Returns:
      DistanceData: Returns the distances data of the object as a list of
        tuples. Each tuples has five elements: (chain1, pos1, chain2, pos2,
        distance).
    &#34;&#34;&#34;
    return [
      (chain1, pos1, chain2, pos2, dist)
      for (chain1, pos1), c_pos in self._distances.items()
      for (chain2, pos2), dist in c_pos.items()
    ]

  def of( #pylint: disable=invalid-name
      self,
      chain_a:Chain,
      pos_a:Position,
      chain_b:Chain,
      pos_b:Position
    ) -&gt; Optional[Distance]:
    &#34;&#34;&#34;
    Retrieves distance for a residue pair.

    Args:
      chain_a (str): A string specifying the first residue chain.
      pos_a (int): An integer specifying the first residue position.
      chain_b (str): A string specifying the second residue chain.
      pos_b (int): An integer specifying the second residue position.

    Returns:
      Optional[float]: The distance between two residue positions. If the pair
        is not found, None is returned.
    &#34;&#34;&#34;
    pair1 = ((chain_a, pos_a))
    pair2 = ((chain_b, pos_b))
    if pair1 == pair2: # Special case for distance with the same residue.
      return 0
    distance = self._distances.get(pair1, {}).get(pair2)
    if not distance:
      distance = self._distances.get(pair2, {}).get(pair1)
    return distance

  def remap_positions(
      self,
      mapping: dict[Chain, dict[Position, Position]]
    ):
    &#34;&#34;&#34;
    Remap index positions.
    If a positions could not be mapped it is excluded from the results.

    Args:
      mapping (dict[str, dict[int, float]]): a dict that maps old positions to
        new positions.
    &#34;&#34;&#34;
    T = TypeVar(&#34;T&#34;)
    def _remap(dic: dict[tuple[str, int], T]) -&gt; dict[tuple[str, int], T]:
      return {
        (chain, mapping[chain][pos]):value
        for (chain, pos), value in dic.items()
        if pos in mapping.get(chain, {})
      }

    self._distances = _remap(
      {
        (c1, p1):_remap(r2)
        for (c1, p1), r2 in self._distances.items()
      }
    )

  def is_contact( #pylint: disable=too-many-arguments
      self,
      chain_a: Chain,
      pos_a: Position,
      chain_b: Chain,
      pos_b: Position,
      distance_cutoff:Distance=6.05
    ) -&gt; bool:
    &#39;&#39;&#39;

    Args:
      chain_a (str): A string specifying the first residue chain.
      pos_a (int): An integer specifying the first residue position.
      chain_b (str): A string specifying the second residue chain.
      pos_b (str): An integer specifying the second residue position.
      distance_cutoff (float): a float with the distance cutoff (defaults to
        6.05 angstroms)

    Returns:
      bool: Returns True if a given pair&#39;s distance is lower or equal than a
      given distance cutoff.
    &#39;&#39;&#39;
    dist = self.of(chain_a, pos_a, chain_b, pos_b)
    if dist is None:
      return False
    return dist &lt;= distance_cutoff

  @staticmethod
  def _sum_true(boolean_list: list[bool]):
    return reduce(lambda a, b: a+(1 if b else 0), boolean_list, 0)

  def mean_intramolecular(self) -&gt; dict[Chain, float]:
    &#34;&#34;&#34;
    Returns:
      Return the mean number of intramolecular contacts across all residues for
        every chain.
    &#34;&#34;&#34;
    def _pos_contacts(chain:str, pos1:int, all_positions: list[int]):
      return [
        self.is_contact(chain, pos1, chain, pos2)
        for pos2 in all_positions
        if not pos1 == pos2
      ]
    all_residues = set(self._distances.keys()).union(
      {
        pair2
        for pair1 in self._distances.keys()
        for pair2 in self._distances[pair1].keys()
      }
    )
    all_chains = {chain for chain, _ in all_residues}
    pos_by_chain = {
      chain: [p for c, p in all_residues if c == chain]
      for chain in all_chains
    }
    n_contacts = {
      chain: [
        self._sum_true(_pos_contacts(chain, pos, pos_by_chain[chain]))
        for pos in pos_by_chain[chain]
      ]
      for chain in all_chains
    }
    n_contacts = {
      chain: float(reduce(operator.add, n, 0)) / max(1, len(n))
      for chain, n in n_contacts.items()
    }
    return n_contacts

  @staticmethod
  def from_contact_map(
      contact_map: Dict[Tuple[int, int], bool]
    ) -&gt; &#39;Distances&#39;:
    &#34;&#34;&#34;
    Create a new Distance object from a contact map.
    Set contact to a distace of 1 and non contacts to 10.
    Sets the chain to be &#39;A&#39;.
    &#34;&#34;&#34;
    dist_data = []
    for (pos1, pos2), is_contact in contact_map.items():
      dist_data.append(
        (&#39;A&#39;, pos1, &#39;A&#39;, pos2, 1 if is_contact else 10)
      )
    return Distances(dist_data)

def from_mitos(dist_file: str) -&gt; DistanceData:
  &#34;&#34;&#34;
  Loads data of residue distances from a file generated by MIToS.

  Input data should look like:

  &lt;pre&gt;
  # model_i,chain_i,group_i,pdbe_i,number_i,name_i,model_j,chain_j,group_j,pdbe_j,number_j,name_j,distance
  1,A,ATOM,,55,LEU,1,A,ATOM,,56,LEU,1.3247309160731473
  &lt;/pre&gt;

  Args:
    dist_file (str): A string to a text file with the distance data.

  Returns:
    list[tuple[str, int, str, int, float]]: The distances in the file.
  &#34;&#34;&#34; # pylint: disable=line-too-long
  d_pattern = re.compile(
    r&#34;(\d+),(.),(.+),.*,(\d+),(.+),(\d+),(.),(.+),.*,(\d+),(.+),(.+)$&#34;
  )
  res = []
  with open(dist_file, &#34;r&#34;, encoding=&#34;utf8&#34;) as handle:
    for line in handle:
      line = line.strip()
      if not line.startswith(&#34;#&#34;):
        match = re.match(d_pattern, line)
        if not match:
          continue
        try:
          res.append((
            match.group(2),      # Chain 1
            int(match.group(4)), # Pos res 1
            match.group(7),      # Chain 2
            int(match.group(9)), # Pos res 2
            float(match.group(11))))  # distance
        except (IndexError, AttributeError):
          pass
    return res


def is_back_bone(atom:Atom) -&gt; bool:
  &#34;&#34;&#34;
  Decides if an atom belongs to the backbone of a prototein by their name.

  Args:
    atom (Atom): An atom.

  Returns:
    bool: True if the given atom belongs to the backbone of the protein.
  &#34;&#34;&#34;
  return atom.id in [&#39;N&#39;, &#39;CA&#39;, &#39;CB&#39;]

def all_atoms_selector(atom1:Atom, atom2:Atom) -&gt; bool:
  &#34;&#34;&#34;
  Accepts two any atoms.

  Args:
    atom1 (Atom): An Atom
    atom2 (Atom): An Atom

  Returns:
    bool: True, always.
  &#34;&#34;&#34;
  #pylint: disable=unused-argument
  return True

def side_chain_selector(atom1:Atom, atom2:Atom) -&gt; bool:
  &#34;&#34;&#34;
  Accepts two atoms that are part of the sidechain of an aminoacid.

  Args:
    atom1 (Atom): An Atom.
    atom2 (Atom): An Atom.

  Returns:
    bool: True if both atom are part of the side chain of a residue.
  &#34;&#34;&#34;
  return not is_back_bone(atom1) and not is_back_bone(atom2)

def carbon_alfa_selector(atom1:Atom, atom2:Atom) -&gt; bool:
  &#34;&#34;&#34;
  Accepts two alpha carbon atoms

  Args:
    atom1 (Atom): An Atom
    atom2 (Atom): An Atom

  Returns:
    bool: True if both atom are Alpha Carbons.
  &#34;&#34;&#34;
  return atom1.id == &#39;CA&#39; and atom2.id == &#39;CA&#39;

def carbon_beta_selector(atom1:Atom, atom2:Atom) -&gt; bool:
  &#34;&#34;&#34;
  Accepts two beta carbon atoms

  Args:
    atom1 (Atom): An Atom
    atom2 (Atom): An Atom

  Returns:
    bool: True, if both atoms a Beta Carbons.
  &#34;&#34;&#34;
  return atom1.id == &#39;CB&#39; and atom2.id == &#39;CB&#39;

def _pick_pdb_model(pdb_source) -&gt; Optional[Model]:
  model = None
  if isinstance(pdb_source, Structure):
    struct = pdb_source
    model = list(struct.get_models())[0]
  elif isinstance(pdb_source, Model):
    model = pdb_source
  elif isinstance(pdb_source, str):
    parser = PDBParser()
    struct = parser.get_structure(&#39;XXXX&#39;, pdb_source)
    model = list(struct.get_models())[0]
  return model

def _shorter_distance_between_residues(
    res1: Residue,
    res2: Residue,
    atom_selector: AtomSelector
  ) -&gt; Optional[DistanceElementLong]:
  min_dist = float(&#39;inf&#39;)
  min_res_data = None
  p_1 = res1.parent
  c_1 = str(p_1.id) if p_1 else &#34;&#34;
  p_2 = res2.parent
  c_2 = str(p_2.id) if p_2 else &#34;&#34;
  for atom1, atom2 in product(res1, res2):
    if (
      not atom1.id.startswith(&#39;H&#39;) and
      not atom2.id.startswith(&#39;H&#39;) and
      atom_selector(atom1, atom2)
    ):
      dist = atom1-atom2
      if dist &lt; min_dist:
        min_dist = dist
        sorted_pair = sorted(
          [
            (c_1, res1.id[1], res1.resname, atom1.id),
            (c_2, res2.id[1], res2.resname, atom2.id)
          ]
        )
        min_res_data = (
          sorted_pair[0][0],
          sorted_pair[0][1],
          sorted_pair[0][2],
          sorted_pair[0][3],
          sorted_pair[1][0],
          sorted_pair[1][1],
          sorted_pair[1][2],
          sorted_pair[1][3],
          dist
        )
  if not min_res_data:
    return None
  return min_res_data

def calculate_distances(
    pdb_source:PDBSource,
    atom_selector:AtomSelector=all_atoms_selector,
    include_extra_info:bool=False
  ) -&gt; DistanceDataSH:
  &#34;&#34;&#34;
  Compute distances between residues

  Args:
    pdb_source (PDBSource): a path to a pdb file, a Bio.PDB.Structure or a
      Bio.PDB.Model
    atom_selector (AtomSelector): all_atoms_selector. a function that allows to
      select pairs of atoms to include into the distance calculation.
    include_extra_info (bool): False. If True adds residue name and atom name
      for each contacting atom to the output.

  Returns:
    DistanceDataSH: The distances calculated.

  Throws:
    ValueError: If a PDB model cannot be found in the PDB source.
  &#34;&#34;&#34;
  model = _pick_pdb_model(pdb_source)
  if not model:
    raise ValueError(&#34;PDB source not recognized&#34;)
  chains = model.get_chains()
  out = []
  for chain1, chain2 in combinations_with_replacement(chains, 2):
    if chain1 is chain2:
      res_iter = combinations(chain1, 2)
    else:
      res_iter = product(chain1, chain2)
    for res1, res2 in res_iter:
      min_res_data = None
      if not res1 is res2:
        min_res_data = _shorter_distance_between_residues(
          res1, res2, atom_selector
        )
      if min_res_data:
        if include_extra_info:
          out.append(min_res_data)
        else:
          out.append((
            min_res_data[0],
            min_res_data[1],
            min_res_data[4],
            min_res_data[5],
            min_res_data[8]
          ))
  return out

def save_distances(
    dist_data:DistanceDataSH,
    outfile:str
  ):
  &#34;&#34;&#34;
  Saves distance data to a file.

  Despite the content of the dist_data list, the output file will contain
  nine fields. Missing data fill filled with NA fields.

  Args:
    dist_data (DistanceDataSH): data generated with calculate_distance function.
    outfile (str): exported file.

  Throws:
    ValueError: If input data has wrong number of elements.
  &#34;&#34;&#34;
  with open(outfile, &#39;w&#39;, encoding=&#39;utf8&#39;) as text_handle:
    for row in dist_data:
      if len(row) == 9: # Data with additional info.
        pass
      elif len(row) == 5: # Data with no additional info.
        row = [
          str(row[0]),
          str(row[1]),
          &#34;NA&#34;,
          &#34;NA&#34;,
          str(row[2]),
          str(row[3]),
          &#34;NA&#34;,
          &#34;NA&#34;,
          str(row[4])
        ]
      else:
        raise ValueError(&#34;Distance data has wrong number of element&#34;)
      text_handle.write(&#34; &#34;.join([str(x) for x in row]))
      text_handle.write(&#34;\n&#34;)

def read_distances(
    distance_file: str,
    add_extra_info:bool=False
  ) -&gt; DistanceDataSH:
  &#34;&#34;&#34;
  Read distance data file.

  Args:
    distance_file (str): The input file.
    add_extra_info (bool): Read extra information from input data.

  Returns:
    DistanceDataSH. A List of distances.
  &#34;&#34;&#34;
  out = []
  with open(distance_file, &#34;r&#34;, encoding=&#34;utf-8&#34;) as csv_file:
    csv_reader = csv.reader(csv_file, delimiter=&#39; &#39;)
    for row in csv_reader:
      if len(row) == 9: # Data with additional info.
        if add_extra_info:
          out.append([
            row[0],
            int(row[1]),
            row[2],
            row[3],
            row[4],
            int(row[5]),
            row[6],
            row[7],
            float(row[8])
          ])
        else:
          out.append([
            row[0],
            int(row[1]),
            row[4],
            int(row[5]),
            float(row[8])
          ])
    return out

def contact_map_from_scpe(
    file_handle: TextIO,
    quaternary: bool = False,
    chars: str = &#34;10&#34;
  ) -&gt; Dict[Tuple[int, int], bool]:
  &#34;&#34;&#34;
  Read contact from SCPE output.

  The file content should have as many lines as positions in the protein.
  Each line should have characters from chars argument, separated by a space.
  There should be as many characters in every line as positions in the
  protein.

  Args:
    file_handle (TextIO): handle to the contact map file.
    quaternary (bool): a boolean value that indicates if quaternary contacts
      should be included.
    chars (str): Characters accepted in the contact map.
      This argument is expected to have a length of two characters.
      The first is the value for residue pairs in contact,
      the second one is the value for non contacts. Defaults to &#34;10&#34;.

  Returns:
    Dict[Tuple[int, int], bool]. Returns a dict object from position pairs to
      boolean values that indicates that the corresponding pair is in contact or
      not. Position index start at 1.
  &#34;&#34;&#34;
  contact_line_pattern = re.compile(f&#34;[{chars}]( [{chars}])+$&#34;)
  qtag = &#34;quaternary&#34;
  ttag = &#34;terciary&#34;
  tags = [qtag, ttag]
  target_tag = qtag if quaternary else ttag
  correct_section = False
  position_index = 0
  contact_map = {}
  for line in file_handle:
    line = line.lower()
    c_match = re.match(contact_line_pattern, line)
    if c_match and correct_section:
      position_index += 1
      c_contacts = line.split()
      contact_map.update({
        (position_index, x+1): c == chars[0]
        for x, c in enumerate(c_contacts)})
    else:
      line = line.strip()
      if any(line == t for t in tags):
        correct_section = line == target_tag
  return contact_map

def contact_map_from_text(
    file_handle: TextIO,
    chars: str = &#34;10&#34;
  ) -&gt; Dict[Tuple[int, int], bool]:
  &#34;&#34;&#34;
  Reads the content of a file object as a contact map.

  The file content should have as many lines as positions in the protein.
  Each line should have characters from chars argument, separated by a space.
  There should be as many characters in every line as positions in the
  protein.

  Args:
    file_handle (TextIO):. handle to the contact map file.
    chars (str): Characters accepted in the contact map.
      This argument is expected to have a length of two characters.
      The first is the value for residue pairs in contact,
      the second one is the value for non contacts.

  Returns:
    Dict[Tuple[int, int], bool]. Returns a dict object from position pairs to
      boolean values that indicates that the corresponding pair is in contact or
      not. Position index start at 1.
  &#34;&#34;&#34;
  contact_line_pattern = re.compile(f&#34;[{chars}]( [{chars}])+$&#34;)
  position_index = 0
  contact_map = {}
  for line in file_handle:
    line = line.strip().lower()
    c_match = re.match(contact_line_pattern, line)
    if c_match:
      position_index += 1
      c_contacts = line.split()
      contact_map.update({
        (position_index, x+1): c == chars[0]
        for x, c in enumerate(c_contacts)})
  return contact_map


def calculate_distances_between_regions(
    pdbsrc:PDBSource,
    chain1:Chain,
    chain2:Chain,
    region1:List[Position],
    region2:List[Position]
  ) -&gt; DistanceDataLong:
  &#34;&#34;&#34;
  Calculate the distances between residues of two regions
  in a pdb structure.
  The distance between two residues is the shortest distance between any
  two atoms in those residues.

  Args:
    pdbsrc (PDBSource): An input pdb structure.
    chain1 (str): The chain ID of the first region.
    chain2 (str): The chain ID of the second region.
    region1 (List[int]): A list with the residue numbers of the first region.
    region2 (List[int]): A list with the residue numbers of the second region.

  Returns:
    DistanceDataLong: A list with the distances, atom information and
      residue information for all residue pairs. Between regions.
  &#34;&#34;&#34;
  def _select_residues(struc, residues, c_chain):
    selected = []
    for st_chain in struc[0].get_chains():
      if not st_chain.id == c_chain:
        continue
      for res in st_chain.get_residues():
        _, rid, _ = res.id
        if not rid in residues:
          continue
        selected.append(res)
    return selected
  struct = pdb_structure_from(pdbsrc)
  res1 = _select_residues(struct, region1, chain1)
  res2 = _select_residues(
    struct, region2, chain2
  )
  distances = [
    maybe_dist
    for r1, r2 in product(res1, res2)
    for maybe_dist in [
      _shorter_distance_between_residues(r1, r2, all_atoms_selector)
    ]
    if maybe_dist is not None
  ]
  return distances</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="xi_covutils.distances.all_atoms_selector"><code class="name flex">
<span>def <span class="ident">all_atoms_selector</span></span>(<span>atom1: Bio.PDB.Atom.Atom, atom2: Bio.PDB.Atom.Atom) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Accepts two any atoms.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>atom1</code></strong> :&ensp;<code>Atom</code></dt>
<dd>An Atom</dd>
<dt><strong><code>atom2</code></strong> :&ensp;<code>Atom</code></dt>
<dd>An Atom</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True, always.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_atoms_selector(atom1:Atom, atom2:Atom) -&gt; bool:
  &#34;&#34;&#34;
  Accepts two any atoms.

  Args:
    atom1 (Atom): An Atom
    atom2 (Atom): An Atom

  Returns:
    bool: True, always.
  &#34;&#34;&#34;
  #pylint: disable=unused-argument
  return True</code></pre>
</details>
</dd>
<dt id="xi_covutils.distances.calculate_distances"><code class="name flex">
<span>def <span class="ident">calculate_distances</span></span>(<span>pdb_source: Union[str, Bio.PDB.Structure.Structure], atom_selector: Callable[[Bio.PDB.Atom.Atom, Bio.PDB.Atom.Atom], bool] = &lt;function all_atoms_selector&gt;, include_extra_info: bool = False) ‑> List[Union[Tuple[str, int, str, int, float], Tuple[str, int, str, str, str, int, str, str, float]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute distances between residues</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pdb_source</code></strong> :&ensp;<code>PDBSource</code></dt>
<dd>a path to a pdb file, a Bio.PDB.Structure or a
Bio.PDB.Model</dd>
<dt><strong><code>atom_selector</code></strong> :&ensp;<code>AtomSelector</code></dt>
<dd>all_atoms_selector. a function that allows to
select pairs of atoms to include into the distance calculation.</dd>
<dt><strong><code>include_extra_info</code></strong> :&ensp;<code>bool</code></dt>
<dd>False. If True adds residue name and atom name
for each contacting atom to the output.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DistanceDataSH</code></dt>
<dd>The distances calculated.</dd>
</dl>
<h2 id="throws">Throws</h2>
<p>ValueError: If a PDB model cannot be found in the PDB source.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_distances(
    pdb_source:PDBSource,
    atom_selector:AtomSelector=all_atoms_selector,
    include_extra_info:bool=False
  ) -&gt; DistanceDataSH:
  &#34;&#34;&#34;
  Compute distances between residues

  Args:
    pdb_source (PDBSource): a path to a pdb file, a Bio.PDB.Structure or a
      Bio.PDB.Model
    atom_selector (AtomSelector): all_atoms_selector. a function that allows to
      select pairs of atoms to include into the distance calculation.
    include_extra_info (bool): False. If True adds residue name and atom name
      for each contacting atom to the output.

  Returns:
    DistanceDataSH: The distances calculated.

  Throws:
    ValueError: If a PDB model cannot be found in the PDB source.
  &#34;&#34;&#34;
  model = _pick_pdb_model(pdb_source)
  if not model:
    raise ValueError(&#34;PDB source not recognized&#34;)
  chains = model.get_chains()
  out = []
  for chain1, chain2 in combinations_with_replacement(chains, 2):
    if chain1 is chain2:
      res_iter = combinations(chain1, 2)
    else:
      res_iter = product(chain1, chain2)
    for res1, res2 in res_iter:
      min_res_data = None
      if not res1 is res2:
        min_res_data = _shorter_distance_between_residues(
          res1, res2, atom_selector
        )
      if min_res_data:
        if include_extra_info:
          out.append(min_res_data)
        else:
          out.append((
            min_res_data[0],
            min_res_data[1],
            min_res_data[4],
            min_res_data[5],
            min_res_data[8]
          ))
  return out</code></pre>
</details>
</dd>
<dt id="xi_covutils.distances.calculate_distances_between_regions"><code class="name flex">
<span>def <span class="ident">calculate_distances_between_regions</span></span>(<span>pdbsrc: Union[str, Bio.PDB.Structure.Structure], chain1: str, chain2: str, region1: List[int], region2: List[int]) ‑> List[Tuple[str, int, str, str, str, int, str, str, float]]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the distances between residues of two regions
in a pdb structure.
The distance between two residues is the shortest distance between any
two atoms in those residues.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pdbsrc</code></strong> :&ensp;<code>PDBSource</code></dt>
<dd>An input pdb structure.</dd>
<dt><strong><code>chain1</code></strong> :&ensp;<code>str</code></dt>
<dd>The chain ID of the first region.</dd>
<dt><strong><code>chain2</code></strong> :&ensp;<code>str</code></dt>
<dd>The chain ID of the second region.</dd>
<dt><strong><code>region1</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>A list with the residue numbers of the first region.</dd>
<dt><strong><code>region2</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>A list with the residue numbers of the second region.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DistanceDataLong</code></dt>
<dd>A list with the distances, atom information and
residue information for all residue pairs. Between regions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_distances_between_regions(
    pdbsrc:PDBSource,
    chain1:Chain,
    chain2:Chain,
    region1:List[Position],
    region2:List[Position]
  ) -&gt; DistanceDataLong:
  &#34;&#34;&#34;
  Calculate the distances between residues of two regions
  in a pdb structure.
  The distance between two residues is the shortest distance between any
  two atoms in those residues.

  Args:
    pdbsrc (PDBSource): An input pdb structure.
    chain1 (str): The chain ID of the first region.
    chain2 (str): The chain ID of the second region.
    region1 (List[int]): A list with the residue numbers of the first region.
    region2 (List[int]): A list with the residue numbers of the second region.

  Returns:
    DistanceDataLong: A list with the distances, atom information and
      residue information for all residue pairs. Between regions.
  &#34;&#34;&#34;
  def _select_residues(struc, residues, c_chain):
    selected = []
    for st_chain in struc[0].get_chains():
      if not st_chain.id == c_chain:
        continue
      for res in st_chain.get_residues():
        _, rid, _ = res.id
        if not rid in residues:
          continue
        selected.append(res)
    return selected
  struct = pdb_structure_from(pdbsrc)
  res1 = _select_residues(struct, region1, chain1)
  res2 = _select_residues(
    struct, region2, chain2
  )
  distances = [
    maybe_dist
    for r1, r2 in product(res1, res2)
    for maybe_dist in [
      _shorter_distance_between_residues(r1, r2, all_atoms_selector)
    ]
    if maybe_dist is not None
  ]
  return distances</code></pre>
</details>
</dd>
<dt id="xi_covutils.distances.carbon_alfa_selector"><code class="name flex">
<span>def <span class="ident">carbon_alfa_selector</span></span>(<span>atom1: Bio.PDB.Atom.Atom, atom2: Bio.PDB.Atom.Atom) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Accepts two alpha carbon atoms</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>atom1</code></strong> :&ensp;<code>Atom</code></dt>
<dd>An Atom</dd>
<dt><strong><code>atom2</code></strong> :&ensp;<code>Atom</code></dt>
<dd>An Atom</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if both atom are Alpha Carbons.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def carbon_alfa_selector(atom1:Atom, atom2:Atom) -&gt; bool:
  &#34;&#34;&#34;
  Accepts two alpha carbon atoms

  Args:
    atom1 (Atom): An Atom
    atom2 (Atom): An Atom

  Returns:
    bool: True if both atom are Alpha Carbons.
  &#34;&#34;&#34;
  return atom1.id == &#39;CA&#39; and atom2.id == &#39;CA&#39;</code></pre>
</details>
</dd>
<dt id="xi_covutils.distances.carbon_beta_selector"><code class="name flex">
<span>def <span class="ident">carbon_beta_selector</span></span>(<span>atom1: Bio.PDB.Atom.Atom, atom2: Bio.PDB.Atom.Atom) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Accepts two beta carbon atoms</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>atom1</code></strong> :&ensp;<code>Atom</code></dt>
<dd>An Atom</dd>
<dt><strong><code>atom2</code></strong> :&ensp;<code>Atom</code></dt>
<dd>An Atom</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True, if both atoms a Beta Carbons.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def carbon_beta_selector(atom1:Atom, atom2:Atom) -&gt; bool:
  &#34;&#34;&#34;
  Accepts two beta carbon atoms

  Args:
    atom1 (Atom): An Atom
    atom2 (Atom): An Atom

  Returns:
    bool: True, if both atoms a Beta Carbons.
  &#34;&#34;&#34;
  return atom1.id == &#39;CB&#39; and atom2.id == &#39;CB&#39;</code></pre>
</details>
</dd>
<dt id="xi_covutils.distances.contact_map_from_scpe"><code class="name flex">
<span>def <span class="ident">contact_map_from_scpe</span></span>(<span>file_handle: <class 'TextIO'>, quaternary: bool = False, chars: str = '10') ‑> Dict[Tuple[int, int], bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Read contact from SCPE output.</p>
<p>The file content should have as many lines as positions in the protein.
Each line should have characters from chars argument, separated by a space.
There should be as many characters in every line as positions in the
protein.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_handle</code></strong> :&ensp;<code>TextIO</code></dt>
<dd>handle to the contact map file.</dd>
<dt><strong><code>quaternary</code></strong> :&ensp;<code>bool</code></dt>
<dd>a boolean value that indicates if quaternary contacts
should be included.</dd>
<dt><strong><code>chars</code></strong> :&ensp;<code>str</code></dt>
<dd>Characters accepted in the contact map.
This argument is expected to have a length of two characters.
The first is the value for residue pairs in contact,
the second one is the value for non contacts. Defaults to "10".</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict[Tuple[int, int], bool]. Returns a dict object from position pairs to
boolean values that indicates that the corresponding pair is in contact or
not. Position index start at 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contact_map_from_scpe(
    file_handle: TextIO,
    quaternary: bool = False,
    chars: str = &#34;10&#34;
  ) -&gt; Dict[Tuple[int, int], bool]:
  &#34;&#34;&#34;
  Read contact from SCPE output.

  The file content should have as many lines as positions in the protein.
  Each line should have characters from chars argument, separated by a space.
  There should be as many characters in every line as positions in the
  protein.

  Args:
    file_handle (TextIO): handle to the contact map file.
    quaternary (bool): a boolean value that indicates if quaternary contacts
      should be included.
    chars (str): Characters accepted in the contact map.
      This argument is expected to have a length of two characters.
      The first is the value for residue pairs in contact,
      the second one is the value for non contacts. Defaults to &#34;10&#34;.

  Returns:
    Dict[Tuple[int, int], bool]. Returns a dict object from position pairs to
      boolean values that indicates that the corresponding pair is in contact or
      not. Position index start at 1.
  &#34;&#34;&#34;
  contact_line_pattern = re.compile(f&#34;[{chars}]( [{chars}])+$&#34;)
  qtag = &#34;quaternary&#34;
  ttag = &#34;terciary&#34;
  tags = [qtag, ttag]
  target_tag = qtag if quaternary else ttag
  correct_section = False
  position_index = 0
  contact_map = {}
  for line in file_handle:
    line = line.lower()
    c_match = re.match(contact_line_pattern, line)
    if c_match and correct_section:
      position_index += 1
      c_contacts = line.split()
      contact_map.update({
        (position_index, x+1): c == chars[0]
        for x, c in enumerate(c_contacts)})
    else:
      line = line.strip()
      if any(line == t for t in tags):
        correct_section = line == target_tag
  return contact_map</code></pre>
</details>
</dd>
<dt id="xi_covutils.distances.contact_map_from_text"><code class="name flex">
<span>def <span class="ident">contact_map_from_text</span></span>(<span>file_handle: <class 'TextIO'>, chars: str = '10') ‑> Dict[Tuple[int, int], bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the content of a file object as a contact map.</p>
<p>The file content should have as many lines as positions in the protein.
Each line should have characters from chars argument, separated by a space.
There should be as many characters in every line as positions in the
protein.</p>
<h2 id="args">Args</h2>
<dl>
<dt>file_handle (TextIO):. handle to the contact map file.</dt>
<dt><strong><code>chars</code></strong> :&ensp;<code>str</code></dt>
<dd>Characters accepted in the contact map.
This argument is expected to have a length of two characters.
The first is the value for residue pairs in contact,
the second one is the value for non contacts.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Dict[Tuple[int, int], bool]. Returns a dict object from position pairs to
boolean values that indicates that the corresponding pair is in contact or
not. Position index start at 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contact_map_from_text(
    file_handle: TextIO,
    chars: str = &#34;10&#34;
  ) -&gt; Dict[Tuple[int, int], bool]:
  &#34;&#34;&#34;
  Reads the content of a file object as a contact map.

  The file content should have as many lines as positions in the protein.
  Each line should have characters from chars argument, separated by a space.
  There should be as many characters in every line as positions in the
  protein.

  Args:
    file_handle (TextIO):. handle to the contact map file.
    chars (str): Characters accepted in the contact map.
      This argument is expected to have a length of two characters.
      The first is the value for residue pairs in contact,
      the second one is the value for non contacts.

  Returns:
    Dict[Tuple[int, int], bool]. Returns a dict object from position pairs to
      boolean values that indicates that the corresponding pair is in contact or
      not. Position index start at 1.
  &#34;&#34;&#34;
  contact_line_pattern = re.compile(f&#34;[{chars}]( [{chars}])+$&#34;)
  position_index = 0
  contact_map = {}
  for line in file_handle:
    line = line.strip().lower()
    c_match = re.match(contact_line_pattern, line)
    if c_match:
      position_index += 1
      c_contacts = line.split()
      contact_map.update({
        (position_index, x+1): c == chars[0]
        for x, c in enumerate(c_contacts)})
  return contact_map</code></pre>
</details>
</dd>
<dt id="xi_covutils.distances.from_mitos"><code class="name flex">
<span>def <span class="ident">from_mitos</span></span>(<span>dist_file: str) ‑> List[Tuple[str, int, str, int, float]]</span>
</code></dt>
<dd>
<div class="desc"><p>Loads data of residue distances from a file generated by MIToS.</p>
<p>Input data should look like:</p>
<pre>
# model_i,chain_i,group_i,pdbe_i,number_i,name_i,model_j,chain_j,group_j,pdbe_j,number_j,name_j,distance
1,A,ATOM,,55,LEU,1,A,ATOM,,56,LEU,1.3247309160731473
</pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dist_file</code></strong> :&ensp;<code>str</code></dt>
<dd>A string to a text file with the distance data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[tuple[str, int, str, int, float]]</code></dt>
<dd>The distances in the file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_mitos(dist_file: str) -&gt; DistanceData:
  &#34;&#34;&#34;
  Loads data of residue distances from a file generated by MIToS.

  Input data should look like:

  &lt;pre&gt;
  # model_i,chain_i,group_i,pdbe_i,number_i,name_i,model_j,chain_j,group_j,pdbe_j,number_j,name_j,distance
  1,A,ATOM,,55,LEU,1,A,ATOM,,56,LEU,1.3247309160731473
  &lt;/pre&gt;

  Args:
    dist_file (str): A string to a text file with the distance data.

  Returns:
    list[tuple[str, int, str, int, float]]: The distances in the file.
  &#34;&#34;&#34; # pylint: disable=line-too-long
  d_pattern = re.compile(
    r&#34;(\d+),(.),(.+),.*,(\d+),(.+),(\d+),(.),(.+),.*,(\d+),(.+),(.+)$&#34;
  )
  res = []
  with open(dist_file, &#34;r&#34;, encoding=&#34;utf8&#34;) as handle:
    for line in handle:
      line = line.strip()
      if not line.startswith(&#34;#&#34;):
        match = re.match(d_pattern, line)
        if not match:
          continue
        try:
          res.append((
            match.group(2),      # Chain 1
            int(match.group(4)), # Pos res 1
            match.group(7),      # Chain 2
            int(match.group(9)), # Pos res 2
            float(match.group(11))))  # distance
        except (IndexError, AttributeError):
          pass
    return res</code></pre>
</details>
</dd>
<dt id="xi_covutils.distances.is_back_bone"><code class="name flex">
<span>def <span class="ident">is_back_bone</span></span>(<span>atom: Bio.PDB.Atom.Atom) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Decides if an atom belongs to the backbone of a prototein by their name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>atom</code></strong> :&ensp;<code>Atom</code></dt>
<dd>An atom.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the given atom belongs to the backbone of the protein.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_back_bone(atom:Atom) -&gt; bool:
  &#34;&#34;&#34;
  Decides if an atom belongs to the backbone of a prototein by their name.

  Args:
    atom (Atom): An atom.

  Returns:
    bool: True if the given atom belongs to the backbone of the protein.
  &#34;&#34;&#34;
  return atom.id in [&#39;N&#39;, &#39;CA&#39;, &#39;CB&#39;]</code></pre>
</details>
</dd>
<dt id="xi_covutils.distances.read_distances"><code class="name flex">
<span>def <span class="ident">read_distances</span></span>(<span>distance_file: str, add_extra_info: bool = False) ‑> List[Union[Tuple[str, int, str, int, float], Tuple[str, int, str, str, str, int, str, str, float]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Read distance data file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>distance_file</code></strong> :&ensp;<code>str</code></dt>
<dd>The input file.</dd>
<dt><strong><code>add_extra_info</code></strong> :&ensp;<code>bool</code></dt>
<dd>Read extra information from input data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DistanceDataSH. A List of distances.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_distances(
    distance_file: str,
    add_extra_info:bool=False
  ) -&gt; DistanceDataSH:
  &#34;&#34;&#34;
  Read distance data file.

  Args:
    distance_file (str): The input file.
    add_extra_info (bool): Read extra information from input data.

  Returns:
    DistanceDataSH. A List of distances.
  &#34;&#34;&#34;
  out = []
  with open(distance_file, &#34;r&#34;, encoding=&#34;utf-8&#34;) as csv_file:
    csv_reader = csv.reader(csv_file, delimiter=&#39; &#39;)
    for row in csv_reader:
      if len(row) == 9: # Data with additional info.
        if add_extra_info:
          out.append([
            row[0],
            int(row[1]),
            row[2],
            row[3],
            row[4],
            int(row[5]),
            row[6],
            row[7],
            float(row[8])
          ])
        else:
          out.append([
            row[0],
            int(row[1]),
            row[4],
            int(row[5]),
            float(row[8])
          ])
    return out</code></pre>
</details>
</dd>
<dt id="xi_covutils.distances.save_distances"><code class="name flex">
<span>def <span class="ident">save_distances</span></span>(<span>dist_data: List[Union[Tuple[str, int, str, int, float], Tuple[str, int, str, str, str, int, str, str, float]]], outfile: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves distance data to a file.</p>
<p>Despite the content of the dist_data list, the output file will contain
nine fields. Missing data fill filled with NA fields.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dist_data</code></strong> :&ensp;<code>DistanceDataSH</code></dt>
<dd>data generated with calculate_distance function.</dd>
<dt><strong><code>outfile</code></strong> :&ensp;<code>str</code></dt>
<dd>exported file.</dd>
</dl>
<h2 id="throws">Throws</h2>
<p>ValueError: If input data has wrong number of elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_distances(
    dist_data:DistanceDataSH,
    outfile:str
  ):
  &#34;&#34;&#34;
  Saves distance data to a file.

  Despite the content of the dist_data list, the output file will contain
  nine fields. Missing data fill filled with NA fields.

  Args:
    dist_data (DistanceDataSH): data generated with calculate_distance function.
    outfile (str): exported file.

  Throws:
    ValueError: If input data has wrong number of elements.
  &#34;&#34;&#34;
  with open(outfile, &#39;w&#39;, encoding=&#39;utf8&#39;) as text_handle:
    for row in dist_data:
      if len(row) == 9: # Data with additional info.
        pass
      elif len(row) == 5: # Data with no additional info.
        row = [
          str(row[0]),
          str(row[1]),
          &#34;NA&#34;,
          &#34;NA&#34;,
          str(row[2]),
          str(row[3]),
          &#34;NA&#34;,
          &#34;NA&#34;,
          str(row[4])
        ]
      else:
        raise ValueError(&#34;Distance data has wrong number of element&#34;)
      text_handle.write(&#34; &#34;.join([str(x) for x in row]))
      text_handle.write(&#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="xi_covutils.distances.side_chain_selector"><code class="name flex">
<span>def <span class="ident">side_chain_selector</span></span>(<span>atom1: Bio.PDB.Atom.Atom, atom2: Bio.PDB.Atom.Atom) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Accepts two atoms that are part of the sidechain of an aminoacid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>atom1</code></strong> :&ensp;<code>Atom</code></dt>
<dd>An Atom.</dd>
<dt><strong><code>atom2</code></strong> :&ensp;<code>Atom</code></dt>
<dd>An Atom.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if both atom are part of the side chain of a residue.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def side_chain_selector(atom1:Atom, atom2:Atom) -&gt; bool:
  &#34;&#34;&#34;
  Accepts two atoms that are part of the sidechain of an aminoacid.

  Args:
    atom1 (Atom): An Atom.
    atom2 (Atom): An Atom.

  Returns:
    bool: True if both atom are part of the side chain of a residue.
  &#34;&#34;&#34;
  return not is_back_bone(atom1) and not is_back_bone(atom2)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="xi_covutils.distances.Distances"><code class="flex name class">
<span>class <span class="ident">Distances</span></span>
<span>(</span><span>dist_data: List[Tuple[str, int, str, int, float]])</span>
</code></dt>
<dd>
<div class="desc"><p>Store and access distance data for residues from a protein structure.</p>
<p>Creates a new instance from distance data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dist_data</code></strong> :&ensp;<code>DistanceData</code></dt>
<dd>Distance data should be a list of tuples of five
elements: (chain1, pos1, chain2, pos2, distance).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Distances():
  &#39;&#39;&#39;
  Store and access distance data for residues from a protein structure.
  &#39;&#39;&#39;
  def __init__(
      self,
      dist_data: DistanceData
    ):
    &#34;&#34;&#34;
    Creates a new instance from distance data.

    Args:
      dist_data (DistanceData): Distance data should be a list of tuples of five
        elements: (chain1, pos1, chain2, pos2, distance).
    &#34;&#34;&#34;
    dis:Dict[Tuple[Chain, Position], Dict[Tuple[Chain, Position], float]] = {}
    for ch1, po1, ch2, po2, dist in dist_data:
      if (ch1, po1) not in dis:
        dis[(ch1, po1)] = {}
      dis[(ch1, po1)][(ch2, po2)] = dist
    self._distances = dis

  def raw_distances(self) -&gt; DistanceData:
    &#34;&#34;&#34;
    Returns:
      DistanceData: Returns the distances data of the object as a list of
        tuples. Each tuples has five elements: (chain1, pos1, chain2, pos2,
        distance).
    &#34;&#34;&#34;
    return [
      (chain1, pos1, chain2, pos2, dist)
      for (chain1, pos1), c_pos in self._distances.items()
      for (chain2, pos2), dist in c_pos.items()
    ]

  def of( #pylint: disable=invalid-name
      self,
      chain_a:Chain,
      pos_a:Position,
      chain_b:Chain,
      pos_b:Position
    ) -&gt; Optional[Distance]:
    &#34;&#34;&#34;
    Retrieves distance for a residue pair.

    Args:
      chain_a (str): A string specifying the first residue chain.
      pos_a (int): An integer specifying the first residue position.
      chain_b (str): A string specifying the second residue chain.
      pos_b (int): An integer specifying the second residue position.

    Returns:
      Optional[float]: The distance between two residue positions. If the pair
        is not found, None is returned.
    &#34;&#34;&#34;
    pair1 = ((chain_a, pos_a))
    pair2 = ((chain_b, pos_b))
    if pair1 == pair2: # Special case for distance with the same residue.
      return 0
    distance = self._distances.get(pair1, {}).get(pair2)
    if not distance:
      distance = self._distances.get(pair2, {}).get(pair1)
    return distance

  def remap_positions(
      self,
      mapping: dict[Chain, dict[Position, Position]]
    ):
    &#34;&#34;&#34;
    Remap index positions.
    If a positions could not be mapped it is excluded from the results.

    Args:
      mapping (dict[str, dict[int, float]]): a dict that maps old positions to
        new positions.
    &#34;&#34;&#34;
    T = TypeVar(&#34;T&#34;)
    def _remap(dic: dict[tuple[str, int], T]) -&gt; dict[tuple[str, int], T]:
      return {
        (chain, mapping[chain][pos]):value
        for (chain, pos), value in dic.items()
        if pos in mapping.get(chain, {})
      }

    self._distances = _remap(
      {
        (c1, p1):_remap(r2)
        for (c1, p1), r2 in self._distances.items()
      }
    )

  def is_contact( #pylint: disable=too-many-arguments
      self,
      chain_a: Chain,
      pos_a: Position,
      chain_b: Chain,
      pos_b: Position,
      distance_cutoff:Distance=6.05
    ) -&gt; bool:
    &#39;&#39;&#39;

    Args:
      chain_a (str): A string specifying the first residue chain.
      pos_a (int): An integer specifying the first residue position.
      chain_b (str): A string specifying the second residue chain.
      pos_b (str): An integer specifying the second residue position.
      distance_cutoff (float): a float with the distance cutoff (defaults to
        6.05 angstroms)

    Returns:
      bool: Returns True if a given pair&#39;s distance is lower or equal than a
      given distance cutoff.
    &#39;&#39;&#39;
    dist = self.of(chain_a, pos_a, chain_b, pos_b)
    if dist is None:
      return False
    return dist &lt;= distance_cutoff

  @staticmethod
  def _sum_true(boolean_list: list[bool]):
    return reduce(lambda a, b: a+(1 if b else 0), boolean_list, 0)

  def mean_intramolecular(self) -&gt; dict[Chain, float]:
    &#34;&#34;&#34;
    Returns:
      Return the mean number of intramolecular contacts across all residues for
        every chain.
    &#34;&#34;&#34;
    def _pos_contacts(chain:str, pos1:int, all_positions: list[int]):
      return [
        self.is_contact(chain, pos1, chain, pos2)
        for pos2 in all_positions
        if not pos1 == pos2
      ]
    all_residues = set(self._distances.keys()).union(
      {
        pair2
        for pair1 in self._distances.keys()
        for pair2 in self._distances[pair1].keys()
      }
    )
    all_chains = {chain for chain, _ in all_residues}
    pos_by_chain = {
      chain: [p for c, p in all_residues if c == chain]
      for chain in all_chains
    }
    n_contacts = {
      chain: [
        self._sum_true(_pos_contacts(chain, pos, pos_by_chain[chain]))
        for pos in pos_by_chain[chain]
      ]
      for chain in all_chains
    }
    n_contacts = {
      chain: float(reduce(operator.add, n, 0)) / max(1, len(n))
      for chain, n in n_contacts.items()
    }
    return n_contacts

  @staticmethod
  def from_contact_map(
      contact_map: Dict[Tuple[int, int], bool]
    ) -&gt; &#39;Distances&#39;:
    &#34;&#34;&#34;
    Create a new Distance object from a contact map.
    Set contact to a distace of 1 and non contacts to 10.
    Sets the chain to be &#39;A&#39;.
    &#34;&#34;&#34;
    dist_data = []
    for (pos1, pos2), is_contact in contact_map.items():
      dist_data.append(
        (&#39;A&#39;, pos1, &#39;A&#39;, pos2, 1 if is_contact else 10)
      )
    return Distances(dist_data)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="xi_covutils.distances.Distances.from_contact_map"><code class="name flex">
<span>def <span class="ident">from_contact_map</span></span>(<span>contact_map: Dict[Tuple[int, int], bool]) ‑> <a title="xi_covutils.distances.Distances" href="#xi_covutils.distances.Distances">Distances</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a new Distance object from a contact map.
Set contact to a distace of 1 and non contacts to 10.
Sets the chain to be 'A'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_contact_map(
    contact_map: Dict[Tuple[int, int], bool]
  ) -&gt; &#39;Distances&#39;:
  &#34;&#34;&#34;
  Create a new Distance object from a contact map.
  Set contact to a distace of 1 and non contacts to 10.
  Sets the chain to be &#39;A&#39;.
  &#34;&#34;&#34;
  dist_data = []
  for (pos1, pos2), is_contact in contact_map.items():
    dist_data.append(
      (&#39;A&#39;, pos1, &#39;A&#39;, pos2, 1 if is_contact else 10)
    )
  return Distances(dist_data)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xi_covutils.distances.Distances.is_contact"><code class="name flex">
<span>def <span class="ident">is_contact</span></span>(<span>self, chain_a: str, pos_a: int, chain_b: str, pos_b: int, distance_cutoff: float = 6.05) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>chain_a</code></strong> :&ensp;<code>str</code></dt>
<dd>A string specifying the first residue chain.</dd>
<dt><strong><code>pos_a</code></strong> :&ensp;<code>int</code></dt>
<dd>An integer specifying the first residue position.</dd>
<dt><strong><code>chain_b</code></strong> :&ensp;<code>str</code></dt>
<dd>A string specifying the second residue chain.</dd>
<dt><strong><code>pos_b</code></strong> :&ensp;<code>str</code></dt>
<dd>An integer specifying the second residue position.</dd>
<dt><strong><code>distance_cutoff</code></strong> :&ensp;<code>float</code></dt>
<dd>a float with the distance cutoff (defaults to
6.05 angstroms)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Returns True if a given pair's distance is lower or equal than a</dd>
</dl>
<p>given distance cutoff.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_contact( #pylint: disable=too-many-arguments
    self,
    chain_a: Chain,
    pos_a: Position,
    chain_b: Chain,
    pos_b: Position,
    distance_cutoff:Distance=6.05
  ) -&gt; bool:
  &#39;&#39;&#39;

  Args:
    chain_a (str): A string specifying the first residue chain.
    pos_a (int): An integer specifying the first residue position.
    chain_b (str): A string specifying the second residue chain.
    pos_b (str): An integer specifying the second residue position.
    distance_cutoff (float): a float with the distance cutoff (defaults to
      6.05 angstroms)

  Returns:
    bool: Returns True if a given pair&#39;s distance is lower or equal than a
    given distance cutoff.
  &#39;&#39;&#39;
  dist = self.of(chain_a, pos_a, chain_b, pos_b)
  if dist is None:
    return False
  return dist &lt;= distance_cutoff</code></pre>
</details>
</dd>
<dt id="xi_covutils.distances.Distances.mean_intramolecular"><code class="name flex">
<span>def <span class="ident">mean_intramolecular</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>Return the mean number of intramolecular contacts across all residues for
every chain.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_intramolecular(self) -&gt; dict[Chain, float]:
  &#34;&#34;&#34;
  Returns:
    Return the mean number of intramolecular contacts across all residues for
      every chain.
  &#34;&#34;&#34;
  def _pos_contacts(chain:str, pos1:int, all_positions: list[int]):
    return [
      self.is_contact(chain, pos1, chain, pos2)
      for pos2 in all_positions
      if not pos1 == pos2
    ]
  all_residues = set(self._distances.keys()).union(
    {
      pair2
      for pair1 in self._distances.keys()
      for pair2 in self._distances[pair1].keys()
    }
  )
  all_chains = {chain for chain, _ in all_residues}
  pos_by_chain = {
    chain: [p for c, p in all_residues if c == chain]
    for chain in all_chains
  }
  n_contacts = {
    chain: [
      self._sum_true(_pos_contacts(chain, pos, pos_by_chain[chain]))
      for pos in pos_by_chain[chain]
    ]
    for chain in all_chains
  }
  n_contacts = {
    chain: float(reduce(operator.add, n, 0)) / max(1, len(n))
    for chain, n in n_contacts.items()
  }
  return n_contacts</code></pre>
</details>
</dd>
<dt id="xi_covutils.distances.Distances.of"><code class="name flex">
<span>def <span class="ident">of</span></span>(<span>self, chain_a: str, pos_a: int, chain_b: str, pos_b: int) ‑> Optional[float]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves distance for a residue pair.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>chain_a</code></strong> :&ensp;<code>str</code></dt>
<dd>A string specifying the first residue chain.</dd>
<dt><strong><code>pos_a</code></strong> :&ensp;<code>int</code></dt>
<dd>An integer specifying the first residue position.</dd>
<dt><strong><code>chain_b</code></strong> :&ensp;<code>str</code></dt>
<dd>A string specifying the second residue chain.</dd>
<dt><strong><code>pos_b</code></strong> :&ensp;<code>int</code></dt>
<dd>An integer specifying the second residue position.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[float]</code></dt>
<dd>The distance between two residue positions. If the pair
is not found, None is returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def of( #pylint: disable=invalid-name
    self,
    chain_a:Chain,
    pos_a:Position,
    chain_b:Chain,
    pos_b:Position
  ) -&gt; Optional[Distance]:
  &#34;&#34;&#34;
  Retrieves distance for a residue pair.

  Args:
    chain_a (str): A string specifying the first residue chain.
    pos_a (int): An integer specifying the first residue position.
    chain_b (str): A string specifying the second residue chain.
    pos_b (int): An integer specifying the second residue position.

  Returns:
    Optional[float]: The distance between two residue positions. If the pair
      is not found, None is returned.
  &#34;&#34;&#34;
  pair1 = ((chain_a, pos_a))
  pair2 = ((chain_b, pos_b))
  if pair1 == pair2: # Special case for distance with the same residue.
    return 0
  distance = self._distances.get(pair1, {}).get(pair2)
  if not distance:
    distance = self._distances.get(pair2, {}).get(pair1)
  return distance</code></pre>
</details>
</dd>
<dt id="xi_covutils.distances.Distances.raw_distances"><code class="name flex">
<span>def <span class="ident">raw_distances</span></span>(<span>self) ‑> List[Tuple[str, int, str, int, float]]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>DistanceData</code></dt>
<dd>Returns the distances data of the object as a list of
tuples. Each tuples has five elements: (chain1, pos1, chain2, pos2,
distance).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def raw_distances(self) -&gt; DistanceData:
  &#34;&#34;&#34;
  Returns:
    DistanceData: Returns the distances data of the object as a list of
      tuples. Each tuples has five elements: (chain1, pos1, chain2, pos2,
      distance).
  &#34;&#34;&#34;
  return [
    (chain1, pos1, chain2, pos2, dist)
    for (chain1, pos1), c_pos in self._distances.items()
    for (chain2, pos2), dist in c_pos.items()
  ]</code></pre>
</details>
</dd>
<dt id="xi_covutils.distances.Distances.remap_positions"><code class="name flex">
<span>def <span class="ident">remap_positions</span></span>(<span>self, mapping: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Remap index positions.
If a positions could not be mapped it is excluded from the results.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mapping</code></strong> :&ensp;<code>dict[str, dict[int, float]]</code></dt>
<dd>a dict that maps old positions to
new positions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remap_positions(
    self,
    mapping: dict[Chain, dict[Position, Position]]
  ):
  &#34;&#34;&#34;
  Remap index positions.
  If a positions could not be mapped it is excluded from the results.

  Args:
    mapping (dict[str, dict[int, float]]): a dict that maps old positions to
      new positions.
  &#34;&#34;&#34;
  T = TypeVar(&#34;T&#34;)
  def _remap(dic: dict[tuple[str, int], T]) -&gt; dict[tuple[str, int], T]:
    return {
      (chain, mapping[chain][pos]):value
      for (chain, pos), value in dic.items()
      if pos in mapping.get(chain, {})
    }

  self._distances = _remap(
    {
      (c1, p1):_remap(r2)
      for (c1, p1), r2 in self._distances.items()
    }
  )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<svg
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:cc="http://creativecommons.org/ns#"
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns:svg="http://www.w3.org/2000/svg"
xmlns="http://www.w3.org/2000/svg"
width="150px"
height="150px"
viewBox="0 0 120 120"
version="1.1"
id="svg8"
>
<defs
id="defs2" />
<g
inkscape:label="Capa 1"
inkscape:groupmode="layer"
id="layer1"
transform="translate(-49.587788,-35.413692)">
<g
style="opacity:1"
id="g43" />
<rect
ry="0"
y="35.413692"
x="49.587788"
height="120"
width="120"
id="rect1194"
style="fill:#f2f2f2;stroke:none;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stop-color:#000000" />
<path
d="M 143.10997,48.335014 A 23.33687,23.33687 0 0 0 128.57922,53.410732 9.3925143,9.3925143 0 0 0 124.6267,52.538504 9.3925143,9.3925143 0 0 0 116.34692,57.496844 23.33687,23.33687 0 0 0 97.317517,71.848333 9.3925143,9.3925143 0 0 0 92.808551,79.871748 9.3925143,9.3925143 0 0 0 96.55579,87.378016 23.33687,23.33687 0 0 0 104.9667,99.40209 9.3925143,9.3925143 0 0 0 114.27636,107.54976 9.3925143,9.3925143 0 0 0 121.74186,103.85703 23.33687,23.33687 0 0 0 137.80195,94.397092 23.33687,23.33687 0 0 0 143.10997,95.009029 23.33687,23.33687 0 0 0 166.44649,71.672512 23.33687,23.33687 0 0 0 163.74975,60.781941 9.3925143,9.3925143 0 0 0 164.03558,58.481047 9.3925143,9.3925143 0 0 0 154.64293,49.088391 9.3925143,9.3925143 0 0 0 151.14763,49.763189 23.33687,23.33687 0 0 0 143.10997,48.335014 Z"
style="fill:#ccffaa;stroke:#b3ff80;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stop-color:#000000"
id="path204" />
<path
transform="matrix(0.26458333,0,0,0.26458333,49.587788,35.413692)"
d="M 453.54297 200.39648 C 446.1937 200.62707 439.08638 203.12846 433.21289 207.58008 C 430.91728 205.75652 428.53405 204.04891 426.06836 202.46289 C 404.25546 226.81495 369.54952 239.06993 337.27734 233.33594 C 329.64338 242.63365 320.21344 250.42688 309.71289 256.28711 C 303.79521 259.70365 297.50919 262.4106 291.00977 264.42188 C 290.4425 268.47342 290.15828 272.55935 290.1582 276.65039 C 290.15881 303.03414 301.96978 328.03149 322.35156 344.78516 C 322.34536 345.05551 322.34375 345.32528 322.34375 345.5957 C 322.34345 365.20185 338.2376 381.09601 357.84375 381.0957 C 370.1206 381.09514 381.52435 374.75236 388 364.32227 C 404.73439 362.48205 420.59226 355.88946 433.70117 345.32617 C 439.0522 350.88219 446.0304 354.49969 453.54297 355.72852 L 453.54297 200.39648 z "
style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;font-variant-ligatures:normal;font-variant-position:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;font-feature-settings:normal;font-variation-settings:normal;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:normal;word-spacing:normal;text-transform:none;writing-mode:lr-tb;direction:ltr;text-orientation:mixed;dominant-baseline:auto;baseline-shift:baseline;text-anchor:start;white-space:normal;shape-padding:0;shape-margin:0;inline-size:0;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;vector-effect:none;fill:#ffd5e5;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:7.55906;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate;stop-color:#000000"
id="path1240" />
<path
transform="matrix(0.26458333,0,0,0.26458333,49.587788,35.413692)"
d="M 453.54297 196.61914 C 446.38376 196.85036 439.56471 199.30683 433.55273 203.17969 C 431.76797 201.83856 429.99133 200.49123 428.11328 199.2832 L 425.4043 197.54102 L 423.25586 199.93945 C 402.35182 223.27687 368.83504 235.10534 337.93555 229.61523 L 335.75781 229.22461 L 334.35547 230.93555 C 327.03282 239.85409 317.96528 247.35177 307.86914 252.98633 L 307.84766 253 L 307.82422 253.01562 C 302.16184 256.28477 296.13684 258.87887 289.89453 260.81055 L 287.59961 261.51953 L 287.26758 263.89648 C 286.67601 268.12162 286.3809 272.38598 286.38086 276.65234 C 286.38143 303.57551 298.31342 329.00186 318.73633 346.45508 C 319.22052 367.68688 336.50025 384.87925 357.8457 384.87891 C 370.84656 384.87834 382.83772 378.30785 390.13281 367.63477 C 405.96461 365.58082 420.85832 359.35878 433.58984 349.74805 C 439.28859 354.76731 446.13731 358.28237 453.54297 359.50195 L 453.54297 351.88867 C 447.06319 350.69886 441.06249 347.5194 436.42578 342.70508 L 434.02539 340.21094 L 431.33203 342.38086 C 418.78464 352.4917 403.60354 358.80113 387.58594 360.5625 L 385.76367 360.76953 L 384.78906 362.32617 C 379.00011 371.65019 368.82066 377.31787 357.8457 377.31836 C 340.2822 377.31866 326.12474 363.16307 326.125 345.59961 C 326.125 345.35798 326.12729 345.11069 326.13281 344.86914 L 326.17578 343.03125 L 324.75195 341.86328 C 305.2415 325.82588 293.93998 301.90813 293.93945 276.65234 C 293.93949 273.40819 294.2384 270.17468 294.61133 266.95312 C 300.44057 264.97299 306.18055 262.68311 311.55273 259.58594 C 321.87568 253.82484 331.08697 246.15138 338.79297 237.15234 C 370.65427 242.0458 403.95988 230.37486 426.25195 207.24023 C 427.8078 208.31407 429.38656 209.36483 430.86719 210.54102 L 433.16211 212.36328 L 435.49414 210.5918 C 440.71123 206.63769 447.01775 204.40648 453.54297 204.17773 L 453.54297 196.61914 z "
style="color:#000000;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;font-variant-ligatures:normal;font-variant-position:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-variant-east-asian:normal;font-feature-settings:normal;font-variation-settings:normal;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:#000000;letter-spacing:normal;word-spacing:normal;text-transform:none;writing-mode:lr-tb;direction:ltr;text-orientation:mixed;dominant-baseline:auto;baseline-shift:baseline;text-anchor:start;white-space:normal;shape-padding:0;shape-margin:0;inline-size:0;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;vector-effect:none;fill:#ffaacc;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:7.55906;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate;stop-color:#000000"
id="path1242" />
<circle
style="fill:#d40000;stroke:none;stroke-width:0.264583;stop-color:#000000"
id="path10"
cx="118.18265"
cy="76.690811"
r="6.8130941" />
<circle
r="6.8130941"
cy="73.984428"
cx="149.74159"
id="path10-4"
style="fill:#008080;stroke:none;stroke-width:0.264583;stop-color:#000000" />
<circle
r="6.8130941"
cy="116.56841"
cx="147.09317"
id="path10-3"
style="fill:#008000;stroke:none;stroke-width:0.264583;stop-color:#000000" />
<path
style="fill:none;stroke:#808080;stroke-width:2.5;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
d="M 128.11322,74.186529 C 131.53435,72.997051 136.6247,72.459452 139.77213,73.024826"
id="path55"
sodipodi:nodetypes="cc" />
<g
transform="matrix(0.95037384,0,0,0.95037384,157.09629,44.282281)"
id="g190"
style="stroke-width:1.05222">
<path
id="path157"
style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:43.0503px;line-height:1.25;font-family:'Bodoni Bd BT';-inkscape-font-specification:'Bodoni Bd BT';text-align:center;letter-spacing:0px;word-spacing:0px;text-anchor:middle;stroke-width:0.278399"
d="M -109.49264,44.166447 V 42.779083 H -107.43262 Q -106.54975,42.779083 -106.06627,42.526836 -105.5828,42.274588 -104.80503,41.118452 L -98.351693,31.638137 -106.99118,17.470215 H -109.49264 V 16.187955 H -95.892276 V 17.470215 H -98.772106 L -93.958376,25.64725 -89.207708,18.58431 Q -89.186687,18.542269 -89.144646,18.479207 -88.95546,18.205938 -88.95546,17.995732 -88.95546,17.722463 -89.165667,17.596339 -89.375873,17.470215 -89.817307,17.470215 H -92.48693 V 16.187955 H -82.964574 V 17.470215 H -84.814391 Q -86.180734,17.470215 -86.70625,17.743484 -87.210746,17.995732 -87.841365,18.89962 L -93.222653,26.698283 -83.532131,42.779083 H -81.24088 V 44.166447 H -94.71512 V 42.779083 H -91.667125 L -97.61597,32.920396 -102.91317,40.971307 Q -103.08134,41.223555 -103.18644,41.538865 -103.29155,41.854175 -103.29155,42.064381 -103.29155,42.400712 -103.01828,42.589898 -102.74501,42.779083 -102.21949,42.779083 H -99.802118 V 44.166447 Z" />
<path
id="path159"
style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:43.0503px;line-height:1.25;font-family:'Bodoni Bd BT';-inkscape-font-specification:'Bodoni Bd BT';text-align:center;letter-spacing:0px;word-spacing:0px;text-anchor:middle;stroke-width:0.278399"
d="M -80.042703,44.166447 V 42.779083 H -76.595316 V 17.470215 H -80.042703 V 16.187955 H -65.916823 V 17.470215 H -69.36421 V 42.779083 H -65.916823 V 44.166447 Z" />
</g>
<g
transform="matrix(0.95037384,0,0,0.95037384,176.03494,26.941034)"
id="g195"
style="stroke-width:1.05222">
<path
id="path161"
style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:43.0503px;line-height:1.25;font-family:'Bodoni Bd BT';-inkscape-font-specification:'Bodoni Bd BT';text-align:center;letter-spacing:0px;word-spacing:0px;text-anchor:middle;stroke-width:0.278399"
d="M -105.64586,89.592081 V 97.979322 H -107.03322 L -108.92508,96.423794 Q -110.1653,97.537889 -111.86797,98.105446 -113.54963,98.673004 -115.63067,98.673004 -118.5105,98.673004 -120.90686,97.558909 -123.30321,96.444815 -125.36323,94.153563 -127.40224,91.925374 -128.41123,89.402895 -129.42022,86.859396 -129.42022,83.979566 -129.42022,81.141778 -128.41123,78.64032 -127.38122,76.117842 -125.32119,73.868632 -123.26117,71.619422 -120.82277,70.505327 -118.38438,69.391232 -115.50455,69.391232 -113.73881,69.391232 -112.16226,69.895728 -110.58571,70.400224 -109.13529,71.409215 L -107.6218,69.95879 H -106.21342 L -106.04525,77.694391 H -107.53772 Q -108.92508,73.973735 -110.81694,72.334124 -112.7088,70.694513 -115.58863,70.694513 -118.82581,70.694513 -119.98195,72.817599 -121.13808,74.940685 -121.13808,83.475071 -121.13808,87.973491 -121.03298,90.20168 -120.92788,92.42987 -120.67563,93.41784 -120.15011,95.519906 -118.95193,96.444815 -117.75376,97.369723 -115.58863,97.369723 -112.62472,97.369723 -110.29142,95.204596 -107.93711,93.018448 -107.24343,89.592081 Z" />
<path
id="path163"
style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:43.0503px;line-height:1.25;font-family:'Bodoni Bd BT';-inkscape-font-specification:'Bodoni Bd BT';text-align:center;letter-spacing:0px;word-spacing:0px;text-anchor:middle;stroke-width:0.278399"
d="M -92.718158,84.021608 Q -92.718158,89.402895 -92.549992,91.441899 -92.360806,93.459882 -91.898352,94.447852 -91.225691,95.98236 -89.985472,96.655021 -88.745254,97.327682 -86.622168,97.327682 -84.478061,97.327682 -83.237842,96.655021 -81.997624,95.98236 -81.324963,94.447852 -80.841488,93.375799 -80.652302,91.231692 -80.463116,89.087586 -80.463116,84.021608 -80.463116,78.976651 -80.652302,76.832544 -80.841488,74.688437 -81.324963,73.616384 -81.997624,72.081876 -83.237842,71.409215 -84.478061,70.736554 -86.622168,70.736554 -88.745254,70.736554 -89.985472,71.409215 -91.225691,72.081876 -91.898352,73.616384 -92.360806,74.604355 -92.549992,76.643358 -92.718158,78.661341 -92.718158,84.021608 Z M -101.08438,84.021608 Q -101.08438,81.20484 -99.991304,78.6193 -98.89823,76.033759 -96.817185,73.868632 -94.588996,71.619422 -92.087538,70.526348 -89.58608,69.433274 -86.622168,69.433274 -83.637235,69.433274 -81.135777,70.526348 -78.634319,71.619422 -76.40613,73.868632 -74.304064,76.033759 -73.21099,78.64032 -72.096895,81.225861 -72.096895,84.021608 -72.096895,86.880417 -73.21099,89.486978 -74.304064,92.093539 -76.40613,94.237646 -78.571257,96.465835 -81.093736,97.558909 -83.616214,98.630963 -86.622168,98.630963 -89.607101,98.630963 -92.108559,97.558909 -94.610016,96.465835 -96.817185,94.237646 -98.89823,92.093539 -99.991304,89.486978 -101.08438,86.859396 -101.08438,84.021608 Z" />
<path
id="path165"
style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:43.0503px;line-height:1.25;font-family:'Bodoni Bd BT';-inkscape-font-specification:'Bodoni Bd BT';text-align:center;letter-spacing:0px;word-spacing:0px;text-anchor:middle;stroke-width:0.278399"
d="M -57.224781,98.630963 -68.470831,71.283091 H -70.846165 V 70.000831 H -57.666215 V 71.283091 H -60.903396 L -53.756373,88.60411 -48.627333,74.078838 Q -48.375086,73.427198 -48.269982,72.985764 -48.143858,72.54433 -48.143858,72.271062 -48.143858,71.703504 -48.564271,71.493298 -48.963664,71.283091 -50.308986,71.283091 H -52.032679 V 70.000831 H -43.119922 V 71.283091 H -44.318099 Q -45.390153,71.283091 -45.999752,71.871669 -46.609351,72.439227 -47.282012,74.394148 L -55.942521,98.630963 Z" />
</g>
<g
transform="matrix(0.95037384,0,0,0.95037384,194.11456,9.6397395)"
id="g202"
style="stroke-width:1.05222">
<path
id="path167"
style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:43.0503px;line-height:1.25;font-family:'Bodoni Bd BT';-inkscape-font-specification:'Bodoni Bd BT';text-align:center;letter-spacing:0px;word-spacing:0px;text-anchor:middle;stroke-width:0.278399"
d="M -145.16469,144.22476 V 125.09597 H -148.44391 V 123.81371 H -134.44416 V 125.09597 H -138.10175 V 144.07762 Q -138.10175,147.63011 -136.73541,149.26972 -135.34804,150.88831 -132.38413,150.88831 -130.80758,150.88831 -129.52532,150.44688 -128.24306,150.00544 -127.29713,149.12258 -126.2461,148.15562 -125.80467,146.78928 -125.36323,145.42294 -125.36323,141.97555 V 141.55514 127.30314 Q -125.36323,125.87373 -125.72059,125.49536 -126.07794,125.09597 -127.4653,125.09597 H -128.85266 V 123.81371 H -119.98195 V 125.09597 H -121.34829 Q -122.84076,125.09597 -123.30321,125.5374 -123.76566,125.97883 -123.76566,127.34518 V 141.97555 Q -123.76566,145.12865 -124.08097,146.51601 -124.37526,147.90338 -125.11099,148.91237 -126.37223,150.69912 -128.55837,151.58199 -130.74452,152.44384 -134.06578,152.44384 -139.51013,152.44384 -142.34792,150.34177 -145.16469,148.23971 -145.16469,144.22476 Z" />
<path
id="path169"
style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:43.0503px;line-height:1.25;font-family:'Bodoni Bd BT';-inkscape-font-specification:'Bodoni Bd BT';text-align:center;letter-spacing:0px;word-spacing:0px;text-anchor:middle;stroke-width:0.278399"
d="M -111.97308,151.7922 V 150.40483 H -108.52569 V 125.09597 H -110.03918 Q -112.79288,125.09597 -114.39045,126.79864 -115.967,128.50131 -117.1862,132.85259 H -118.30029 L -117.96396,123.81371 H -91.877331 L -91.51998,132.85259 H -92.634074 Q -93.79021,128.62744 -95.408801,126.8617 -97.027391,125.09597 -99.697014,125.09597 H -101.29458 V 150.40483 H -97.847197 V 151.7922 Z" />
<path
id="path171"
style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:43.0503px;line-height:1.25;font-family:'Bodoni Bd BT';-inkscape-font-specification:'Bodoni Bd BT';text-align:center;letter-spacing:0px;word-spacing:0px;text-anchor:middle;stroke-width:0.278399"
d="M -89.544036,151.7922 V 150.40483 H -86.096648 V 125.09597 H -89.544036 V 123.81371 H -75.418156 V 125.09597 H -78.865543 V 150.40483 H -75.418156 V 151.7922 Z" />
<path
id="path173"
style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:43.0503px;line-height:1.25;font-family:'Bodoni Bd BT';-inkscape-font-specification:'Bodoni Bd BT';text-align:center;letter-spacing:0px;word-spacing:0px;text-anchor:middle;stroke-width:0.278399"
d="M -72.412201,151.7922 V 150.40483 H -69.532372 V 125.09597 H -72.412201 V 123.81371 H -58.454487 V 125.09597 H -62.343308 V 150.40483 H -58.24428 Q -54.796893,150.40483 -52.841972,148.57604 -50.887051,146.74724 -49.772956,142.45903 H -48.427634 L -48.742944,151.7922 Z" />
<path
id="path175"
style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:43.0503px;line-height:1.25;font-family:'Bodoni Bd BT';-inkscape-font-specification:'Bodoni Bd BT';text-align:center;letter-spacing:0px;word-spacing:0px;text-anchor:middle;stroke-width:0.278399"
d="M -46.010258,152.12853 V 143.90945 H -44.370647 Q -43.298594,147.48296 -41.196528,149.31176 -39.073442,151.14056 -36.004426,151.14056 -33.250721,151.14056 -31.442944,149.66911 -29.635168,148.19767 -29.635168,145.92744 -29.635168,144.70824 -30.076602,143.93047 -30.497015,143.13169 -31.527027,142.45903 -32.704184,141.68126 -36.172592,140.88248 -37.454852,140.58819 -38.127512,140.42002 -42.184499,139.39001 -44.034316,137.39305 -45.863113,135.39609 -45.863113,132.03278 -45.863113,128.10192 -43.424717,125.68455 -40.965301,123.24615 -37.013418,123.24615 -35.394827,123.24615 -34.007464,123.7086 -32.59908,124.15004 -31.358862,125.05393 L -29.824354,123.81371 H -28.479032 L -28.310867,131.21298 H -29.719251 Q -30.539056,127.95478 -32.451936,126.2521 -34.364815,124.54943 -37.223624,124.54943 -39.598958,124.54943 -41.133466,125.70557 -42.646953,126.8617 -42.646953,128.62744 -42.646953,131.27604 -37.034438,132.51626 -36.277695,132.68442 -35.878302,132.76851 -30.644159,133.9877 -28.542094,136.23691 -26.419008,138.4651 -26.419008,142.58515 -26.419008,146.83132 -29.130672,149.64809 -31.821316,152.44384 -35.920344,152.44384 -38.001389,152.44384 -39.577938,151.96036 -41.154487,151.49791 -42.520829,150.4679 L -44.45473,152.12853 Z" />
</g>
<path
sodipodi:nodetypes="cc"
id="path55-5"
d="M 151.46315,109.23523 C 155.37226,101.50449 154.65059,89.363206 152.75401,81.83054"
style="fill:none;stroke:#808080;stroke-width:2.5;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" />
</g>
</svg>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="xi_covutils" href="index.html">xi_covutils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="xi_covutils.distances.all_atoms_selector" href="#xi_covutils.distances.all_atoms_selector">all_atoms_selector</a></code></li>
<li><code><a title="xi_covutils.distances.calculate_distances" href="#xi_covutils.distances.calculate_distances">calculate_distances</a></code></li>
<li><code><a title="xi_covutils.distances.calculate_distances_between_regions" href="#xi_covutils.distances.calculate_distances_between_regions">calculate_distances_between_regions</a></code></li>
<li><code><a title="xi_covutils.distances.carbon_alfa_selector" href="#xi_covutils.distances.carbon_alfa_selector">carbon_alfa_selector</a></code></li>
<li><code><a title="xi_covutils.distances.carbon_beta_selector" href="#xi_covutils.distances.carbon_beta_selector">carbon_beta_selector</a></code></li>
<li><code><a title="xi_covutils.distances.contact_map_from_scpe" href="#xi_covutils.distances.contact_map_from_scpe">contact_map_from_scpe</a></code></li>
<li><code><a title="xi_covutils.distances.contact_map_from_text" href="#xi_covutils.distances.contact_map_from_text">contact_map_from_text</a></code></li>
<li><code><a title="xi_covutils.distances.from_mitos" href="#xi_covutils.distances.from_mitos">from_mitos</a></code></li>
<li><code><a title="xi_covutils.distances.is_back_bone" href="#xi_covutils.distances.is_back_bone">is_back_bone</a></code></li>
<li><code><a title="xi_covutils.distances.read_distances" href="#xi_covutils.distances.read_distances">read_distances</a></code></li>
<li><code><a title="xi_covutils.distances.save_distances" href="#xi_covutils.distances.save_distances">save_distances</a></code></li>
<li><code><a title="xi_covutils.distances.side_chain_selector" href="#xi_covutils.distances.side_chain_selector">side_chain_selector</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="xi_covutils.distances.Distances" href="#xi_covutils.distances.Distances">Distances</a></code></h4>
<ul class="two-column">
<li><code><a title="xi_covutils.distances.Distances.from_contact_map" href="#xi_covutils.distances.Distances.from_contact_map">from_contact_map</a></code></li>
<li><code><a title="xi_covutils.distances.Distances.is_contact" href="#xi_covutils.distances.Distances.is_contact">is_contact</a></code></li>
<li><code><a title="xi_covutils.distances.Distances.mean_intramolecular" href="#xi_covutils.distances.Distances.mean_intramolecular">mean_intramolecular</a></code></li>
<li><code><a title="xi_covutils.distances.Distances.of" href="#xi_covutils.distances.Distances.of">of</a></code></li>
<li><code><a title="xi_covutils.distances.Distances.raw_distances" href="#xi_covutils.distances.Distances.raw_distances">raw_distances</a></code></li>
<li><code><a title="xi_covutils.distances.Distances.remap_positions" href="#xi_covutils.distances.Distances.remap_positions">remap_positions</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
# This file was auto-generated by Fern from our API Definition.

from ..core.client_wrapper import SyncClientWrapper
import typing
from ..core.request_options import RequestOptions
from ..core.pydantic_utilities import parse_obj_as
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..types.weather_metadata import WeatherMetadata
from ..core.jsonable_encoder import jsonable_encoder
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.http_validation_error import HttpValidationError
from ..types.weather_gauge import WeatherGauge
from ..types.weather_components import WeatherComponents
from ..types.weather_market_context import WeatherMarketContext
from ..core.client_wrapper import AsyncClientWrapper


class MacroClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_segmentations(self, *, request_options: typing.Optional[RequestOptions] = None) -> typing.List[str]:
        """
        Returns the available segmentations for the weather module.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[str]
            Successful Response

        Examples
        --------
        from termina import Termina

        client = Termina(
            token="YOUR_TOKEN",
        )
        client.macro.get_segmentations()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/data/weather/segmentations",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[str],
                    parse_obj_as(
                        type_=typing.List[str],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_metadata(
        self, segmentation: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[WeatherMetadata]:
        """
        Returns segmentation metadata for each of the classes of segmentations "geo" and "sector".

        The geography ("geo") segmentation type refers to major geographic segmentations.

        The "sector" segmentation type refers to major business model categories in the USA geography.

        The metadata includes parameters used to generate the respective indicators, and the metadata needed to
        retrieve the series from the API.

        Parameters
        ----------
        segmentation : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WeatherMetadata]
            Successful Response

        Examples
        --------
        from termina import Termina

        client = Termina(
            token="YOUR_TOKEN",
        )
        client.macro.get_metadata(
            segmentation="segmentation",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/data/weather/{jsonable_encoder(segmentation)}/metadata",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WeatherMetadata],
                    parse_obj_as(
                        type_=typing.List[WeatherMetadata],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_gauge(
        self,
        segmentation: str,
        *,
        slug: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[WeatherGauge]:
        """
        Returns the overall weather indicator, combined across all stages, for the given segmentation slug(s).

        If no slug is provided, the endpoint will return the gauge for all available segmentations.

        Parameters
        ----------
        segmentation : str

        slug : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WeatherGauge]
            Successful Response

        Examples
        --------
        from termina import Termina

        client = Termina(
            token="YOUR_TOKEN",
        )
        client.macro.get_gauge(
            segmentation="segmentation",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/data/weather/{jsonable_encoder(segmentation)}/gauges",
            method="GET",
            params={
                "slug": slug,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WeatherGauge],
                    parse_obj_as(
                        type_=typing.List[WeatherGauge],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_components(
        self, segmentation: str, slug: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[WeatherComponents]:
        """
        Returns the individual components of the weather indicator and some of the underlying inputs of those component gauges for the given segmentation slug.

        Parameters
        ----------
        segmentation : str

        slug : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WeatherComponents]
            Successful Response

        Examples
        --------
        from termina import Termina

        client = Termina(
            token="YOUR_TOKEN",
        )
        client.macro.get_components(
            segmentation="segmentation",
            slug="slug",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/data/weather/{jsonable_encoder(segmentation)}/{jsonable_encoder(slug)}/components",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WeatherComponents],
                    parse_obj_as(
                        type_=typing.List[WeatherComponents],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_market_context(
        self, segmentation: str, slug: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[WeatherMarketContext]:
        """
        Returns simplified contextual metrics about relevant stages and market activity for the given segmentation slug.

        Parameters
        ----------
        segmentation : str

        slug : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WeatherMarketContext]
            Successful Response

        Examples
        --------
        from termina import Termina

        client = Termina(
            token="YOUR_TOKEN",
        )
        client.macro.get_market_context(
            segmentation="segmentation",
            slug="slug",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/data/weather/{jsonable_encoder(segmentation)}/{jsonable_encoder(slug)}/market-context",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WeatherMarketContext],
                    parse_obj_as(
                        type_=typing.List[WeatherMarketContext],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncMacroClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_segmentations(self, *, request_options: typing.Optional[RequestOptions] = None) -> typing.List[str]:
        """
        Returns the available segmentations for the weather module.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[str]
            Successful Response

        Examples
        --------
        import asyncio

        from termina import AsyncTermina

        client = AsyncTermina(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.macro.get_segmentations()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/data/weather/segmentations",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[str],
                    parse_obj_as(
                        type_=typing.List[str],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_metadata(
        self, segmentation: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[WeatherMetadata]:
        """
        Returns segmentation metadata for each of the classes of segmentations "geo" and "sector".

        The geography ("geo") segmentation type refers to major geographic segmentations.

        The "sector" segmentation type refers to major business model categories in the USA geography.

        The metadata includes parameters used to generate the respective indicators, and the metadata needed to
        retrieve the series from the API.

        Parameters
        ----------
        segmentation : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WeatherMetadata]
            Successful Response

        Examples
        --------
        import asyncio

        from termina import AsyncTermina

        client = AsyncTermina(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.macro.get_metadata(
                segmentation="segmentation",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/data/weather/{jsonable_encoder(segmentation)}/metadata",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WeatherMetadata],
                    parse_obj_as(
                        type_=typing.List[WeatherMetadata],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_gauge(
        self,
        segmentation: str,
        *,
        slug: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[WeatherGauge]:
        """
        Returns the overall weather indicator, combined across all stages, for the given segmentation slug(s).

        If no slug is provided, the endpoint will return the gauge for all available segmentations.

        Parameters
        ----------
        segmentation : str

        slug : typing.Optional[typing.Union[str, typing.Sequence[str]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WeatherGauge]
            Successful Response

        Examples
        --------
        import asyncio

        from termina import AsyncTermina

        client = AsyncTermina(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.macro.get_gauge(
                segmentation="segmentation",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/data/weather/{jsonable_encoder(segmentation)}/gauges",
            method="GET",
            params={
                "slug": slug,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WeatherGauge],
                    parse_obj_as(
                        type_=typing.List[WeatherGauge],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_components(
        self, segmentation: str, slug: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[WeatherComponents]:
        """
        Returns the individual components of the weather indicator and some of the underlying inputs of those component gauges for the given segmentation slug.

        Parameters
        ----------
        segmentation : str

        slug : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WeatherComponents]
            Successful Response

        Examples
        --------
        import asyncio

        from termina import AsyncTermina

        client = AsyncTermina(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.macro.get_components(
                segmentation="segmentation",
                slug="slug",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/data/weather/{jsonable_encoder(segmentation)}/{jsonable_encoder(slug)}/components",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WeatherComponents],
                    parse_obj_as(
                        type_=typing.List[WeatherComponents],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_market_context(
        self, segmentation: str, slug: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[WeatherMarketContext]:
        """
        Returns simplified contextual metrics about relevant stages and market activity for the given segmentation slug.

        Parameters
        ----------
        segmentation : str

        slug : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[WeatherMarketContext]
            Successful Response

        Examples
        --------
        import asyncio

        from termina import AsyncTermina

        client = AsyncTermina(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.macro.get_market_context(
                segmentation="segmentation",
                slug="slug",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/data/weather/{jsonable_encoder(segmentation)}/{jsonable_encoder(slug)}/market-context",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[WeatherMarketContext],
                    parse_obj_as(
                        type_=typing.List[WeatherMarketContext],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

import datetime
import numpy as np
from _typeshed import Incomplete
from py4j.java_gateway import GatewayClient, JavaObject
from typing import Any, Iterator, TypeVar, overload

__all__ = ['DataType', 'NullType', 'CharType', 'StringType', 'VarcharType', 'BinaryType', 'BooleanType', 'DateType', 'TimestampType', 'TimestampNTZType', 'DecimalType', 'DoubleType', 'FloatType', 'ByteType', 'IntegerType', 'LongType', 'DayTimeIntervalType', 'YearMonthIntervalType', 'Row', 'ShortType', 'ArrayType', 'MapType', 'StructField', 'StructType']

T = TypeVar('T')
U = TypeVar('U')

class DataType:
    def __hash__(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    @classmethod
    def typeName(cls) -> str: ...
    def simpleString(self) -> str: ...
    def jsonValue(self) -> str | dict[str, Any]: ...
    def json(self) -> str: ...
    def needConversion(self) -> bool: ...
    def toInternal(self, obj: Any) -> Any: ...
    def fromInternal(self, obj: Any) -> Any: ...

class DataTypeSingleton(type):
    def __call__(cls) -> T: ...

class NullType(DataType, metaclass=DataTypeSingleton):
    @classmethod
    def typeName(cls) -> str: ...

class AtomicType(DataType): ...
class NumericType(AtomicType): ...
class IntegralType(NumericType, metaclass=DataTypeSingleton): ...
class FractionalType(NumericType): ...
class StringType(AtomicType, metaclass=DataTypeSingleton): ...

class CharType(AtomicType):
    length: Incomplete
    def __init__(self, length: int) -> None: ...
    def simpleString(self) -> str: ...
    def jsonValue(self) -> str: ...

class VarcharType(AtomicType):
    length: Incomplete
    def __init__(self, length: int) -> None: ...
    def simpleString(self) -> str: ...
    def jsonValue(self) -> str: ...

class BinaryType(AtomicType, metaclass=DataTypeSingleton): ...
class BooleanType(AtomicType, metaclass=DataTypeSingleton): ...

class DateType(AtomicType, metaclass=DataTypeSingleton):
    EPOCH_ORDINAL: Incomplete
    def needConversion(self) -> bool: ...
    def toInternal(self, d: datetime.date) -> int: ...
    def fromInternal(self, v: int) -> datetime.date: ...

class TimestampType(AtomicType, metaclass=DataTypeSingleton):
    def needConversion(self) -> bool: ...
    def toInternal(self, dt: datetime.datetime) -> int: ...
    def fromInternal(self, ts: int) -> datetime.datetime: ...

class TimestampNTZType(AtomicType, metaclass=DataTypeSingleton):
    def needConversion(self) -> bool: ...
    @classmethod
    def typeName(cls) -> str: ...
    def toInternal(self, dt: datetime.datetime) -> int: ...
    def fromInternal(self, ts: int) -> datetime.datetime: ...

class DecimalType(FractionalType):
    precision: Incomplete
    scale: Incomplete
    hasPrecisionInfo: bool
    def __init__(self, precision: int = 10, scale: int = 0) -> None: ...
    def simpleString(self) -> str: ...
    def jsonValue(self) -> str: ...

class DoubleType(FractionalType, metaclass=DataTypeSingleton): ...
class FloatType(FractionalType, metaclass=DataTypeSingleton): ...

class ByteType(IntegralType):
    def simpleString(self) -> str: ...

class IntegerType(IntegralType):
    def simpleString(self) -> str: ...

class LongType(IntegralType):
    def simpleString(self) -> str: ...

class ShortType(IntegralType):
    def simpleString(self) -> str: ...

class AnsiIntervalType(AtomicType): ...

class DayTimeIntervalType(AnsiIntervalType):
    DAY: int
    HOUR: int
    MINUTE: int
    SECOND: int
    startField: Incomplete
    endField: Incomplete
    def __init__(self, startField: int | None = None, endField: int | None = None) -> None: ...
    simpleString: Incomplete
    jsonValue: Incomplete
    def needConversion(self) -> bool: ...
    def toInternal(self, dt: datetime.timedelta) -> int | None: ...
    def fromInternal(self, micros: int) -> datetime.timedelta | None: ...

class YearMonthIntervalType(AnsiIntervalType):
    YEAR: int
    MONTH: int
    startField: Incomplete
    endField: Incomplete
    def __init__(self, startField: int | None = None, endField: int | None = None) -> None: ...
    simpleString: Incomplete
    jsonValue: Incomplete

class ArrayType(DataType):
    elementType: Incomplete
    containsNull: Incomplete
    def __init__(self, elementType: DataType, containsNull: bool = True) -> None: ...
    def simpleString(self) -> str: ...
    def jsonValue(self) -> dict[str, Any]: ...
    @classmethod
    def fromJson(cls, json: dict[str, Any]) -> ArrayType: ...
    def needConversion(self) -> bool: ...
    def toInternal(self, obj: list[T | None]) -> list[T | None]: ...
    def fromInternal(self, obj: list[T | None]) -> list[T | None]: ...

class MapType(DataType):
    keyType: Incomplete
    valueType: Incomplete
    valueContainsNull: Incomplete
    def __init__(self, keyType: DataType, valueType: DataType, valueContainsNull: bool = True) -> None: ...
    def simpleString(self) -> str: ...
    def jsonValue(self) -> dict[str, Any]: ...
    @classmethod
    def fromJson(cls, json: dict[str, Any]) -> MapType: ...
    def needConversion(self) -> bool: ...
    def toInternal(self, obj: dict[T, U | None]) -> dict[T, U | None]: ...
    def fromInternal(self, obj: dict[T, U | None]) -> dict[T, U | None]: ...

class StructField(DataType):
    name: Incomplete
    dataType: Incomplete
    nullable: Incomplete
    metadata: Incomplete
    def __init__(self, name: str, dataType: DataType, nullable: bool = True, metadata: dict[str, Any] | None = None) -> None: ...
    def simpleString(self) -> str: ...
    def jsonValue(self) -> dict[str, Any]: ...
    @classmethod
    def fromJson(cls, json: dict[str, Any]) -> StructField: ...
    def needConversion(self) -> bool: ...
    def toInternal(self, obj: T) -> T: ...
    def fromInternal(self, obj: T) -> T: ...
    def typeName(self) -> str: ...

class StructType(DataType):
    fields: Incomplete
    names: Incomplete
    def __init__(self, fields: list[StructField] | None = None) -> None: ...
    @overload
    def add(self, field: str, data_type: str | DataType, nullable: bool = True, metadata: dict[str, Any] | None = None) -> StructType: ...
    @overload
    def add(self, field: StructField) -> StructType: ...
    def __iter__(self) -> Iterator[StructField]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: str | int) -> StructField: ...
    def simpleString(self) -> str: ...
    def jsonValue(self) -> dict[str, Any]: ...
    @classmethod
    def fromJson(cls, json: dict[str, Any]) -> StructType: ...
    def fieldNames(self) -> list[str]: ...
    def needConversion(self) -> bool: ...
    def toInternal(self, obj: tuple) -> tuple: ...
    def fromInternal(self, obj: tuple) -> Row: ...

class UserDefinedType(DataType):
    @classmethod
    def typeName(cls) -> str: ...
    @classmethod
    def sqlType(cls) -> DataType: ...
    @classmethod
    def module(cls) -> str: ...
    @classmethod
    def scalaUDT(cls) -> str: ...
    def needConversion(self) -> bool: ...
    def toInternal(self, obj: Any) -> Any: ...
    def fromInternal(self, obj: Any) -> Any: ...
    def serialize(self, obj: Any) -> Any: ...
    def deserialize(self, datum: Any) -> Any: ...
    def simpleString(self) -> str: ...
    def json(self) -> str: ...
    def jsonValue(self) -> dict[str, Any]: ...
    @classmethod
    def fromJson(cls, json: dict[str, Any]) -> UserDefinedType: ...
    def __eq__(self, other: Any) -> bool: ...

class Row(tuple):
    @overload
    def __new__(cls, *args: str) -> Row: ...
    @overload
    def __new__(cls, **kwargs: Any) -> Row: ...
    def asDict(self, recursive: bool = False) -> dict[str, Any]: ...
    def __contains__(self, item: Any) -> bool: ...
    def __call__(self, *args: Any) -> Row: ...
    def __getitem__(self, item: Any) -> Any: ...
    def __getattr__(self, item: str) -> Any: ...
    def __setattr__(self, key: Any, value: Any) -> None: ...
    def __reduce__(self) -> str | tuple[Any, ...]: ...

class DateConverter:
    def can_convert(self, obj: Any) -> bool: ...
    def convert(self, obj: datetime.date, gateway_client: GatewayClient) -> JavaObject: ...

class DatetimeConverter:
    def can_convert(self, obj: Any) -> bool: ...
    def convert(self, obj: datetime.datetime, gateway_client: GatewayClient) -> JavaObject: ...

class DatetimeNTZConverter:
    def can_convert(self, obj: Any) -> bool: ...
    def convert(self, obj: datetime.datetime, gateway_client: GatewayClient) -> JavaObject: ...

class DayTimeIntervalTypeConverter:
    def can_convert(self, obj: Any) -> bool: ...
    def convert(self, obj: datetime.timedelta, gateway_client: GatewayClient) -> JavaObject: ...

class NumpyScalarConverter:
    def can_convert(self, obj: Any) -> bool: ...
    def convert(self, obj: np.generic, gateway_client: GatewayClient) -> Any: ...

class NumpyArrayConverter:
    def can_convert(self, obj: Any) -> bool: ...
    def convert(self, obj: np.ndarray, gateway_client: GatewayClient) -> JavaObject: ...

import numpy as np
import pandas as pd
from _typeshed import Incomplete
from pyspark.pandas._typing import Dtype as Dtype, Label as Label, Name as Name, Scalar as Scalar
from pyspark.pandas.base import IndexOpsMixin as IndexOpsMixin
from pyspark.pandas.config import get_option as get_option, option_context as option_context
from pyspark.pandas.frame import DataFrame as DataFrame
from pyspark.pandas.internal import DEFAULT_SERIES_NAME as DEFAULT_SERIES_NAME, InternalField as InternalField, InternalFrame as InternalFrame, SPARK_DEFAULT_INDEX_NAME as SPARK_DEFAULT_INDEX_NAME, SPARK_INDEX_NAME_FORMAT as SPARK_INDEX_NAME_FORMAT
from pyspark.pandas.missing.indexes import MissingPandasLikeIndex as MissingPandasLikeIndex
from pyspark.pandas.series import Series as Series, first_series as first_series
from pyspark.pandas.spark.accessors import SparkIndexMethods as SparkIndexMethods, SparkIndexOpsMethods as SparkIndexOpsMethods
from pyspark.pandas.utils import ERROR_MESSAGE_CANNOT_COMBINE as ERROR_MESSAGE_CANNOT_COMBINE, is_name_like_tuple as is_name_like_tuple, is_name_like_value as is_name_like_value, log_advice as log_advice, name_like_string as name_like_string, same_anchor as same_anchor, scol_for as scol_for, validate_bool_kwarg as validate_bool_kwarg, validate_index_loc as validate_index_loc, verify_temp_column_name as verify_temp_column_name
from pyspark.sql.column import Column as Column
from pyspark.sql.types import DayTimeIntervalType as DayTimeIntervalType, FractionalType as FractionalType, IntegralType as IntegralType, TimestampNTZType as TimestampNTZType, TimestampType as TimestampType
from typing import Any, Callable, Iterator

class Index(IndexOpsMixin):
    def __new__(cls, data: Any | None = None, dtype: str | Dtype | None = None, copy: bool = False, name: Name | None = None, tupleize_cols: bool = True, **kwargs: Any) -> Index: ...
    spark: SparkIndexOpsMethods
    @property
    def size(self) -> int: ...
    @property
    def shape(self) -> tuple: ...
    def identical(self, other: Index) -> bool: ...
    def equals(self, other: Index) -> bool: ...
    def transpose(self) -> Index: ...
    T: Incomplete
    def to_pandas(self) -> pd.Index: ...
    def to_numpy(self, dtype: str | Dtype | None = None, copy: bool = False) -> np.ndarray: ...
    def map(self, mapper: dict | Callable[[Any], Any] | pd.Series, na_action: str | None = None) -> Index: ...
    @property
    def values(self) -> np.ndarray: ...
    @property
    def asi8(self) -> np.ndarray: ...
    @property
    def has_duplicates(self) -> bool: ...
    @property
    def is_unique(self) -> bool: ...
    @property
    def name(self) -> Name: ...
    @name.setter
    def name(self, name: Name) -> None: ...
    @property
    def names(self) -> list[Name]: ...
    @names.setter
    def names(self, names: list[Name]) -> None: ...
    @property
    def nlevels(self) -> int: ...
    def rename(self, name: Name | list[Name], inplace: bool = False) -> Index | None: ...
    def fillna(self, value: Scalar) -> Index: ...
    def drop_duplicates(self, keep: bool | str = 'first') -> Index: ...
    def to_series(self, name: Name | None = None) -> Series: ...
    def to_frame(self, index: bool = True, name: Name | None = None) -> DataFrame: ...
    def is_boolean(self) -> bool: ...
    def is_categorical(self) -> bool: ...
    def is_floating(self) -> bool: ...
    def is_integer(self) -> bool: ...
    def is_interval(self) -> bool: ...
    def is_numeric(self) -> bool: ...
    def is_object(self) -> bool: ...
    def is_type_compatible(self, kind: str) -> bool: ...
    def dropna(self, how: str = 'any') -> Index: ...
    def unique(self, level: int | Name | None = None) -> Index: ...
    def drop(self, labels: list[Any]) -> Index: ...
    def get_level_values(self, level: int | Name) -> Index: ...
    def copy(self, name: Name | None = None, deep: bool | None = None) -> Index: ...
    def droplevel(self, level: int | Name | list[int | Name]) -> Index: ...
    def symmetric_difference(self, other: Index, result_name: Name | None = None, sort: bool | None = None) -> Index: ...
    def sort_values(self, return_indexer: bool = False, ascending: bool = True) -> Index | tuple['Index', 'Index']: ...
    def sort(self, *args, **kwargs) -> None: ...
    def min(self) -> Scalar | tuple[Scalar, ...]: ...
    def max(self) -> Scalar | tuple[Scalar, ...]: ...
    def delete(self, loc: int | list[int]) -> Index: ...
    def append(self, other: Index) -> Index: ...
    def argmax(self) -> int: ...
    def argmin(self) -> int: ...
    def set_names(self, names: Name | list[Name], level: int | Name | list[int | Name] | None = None, inplace: bool = False) -> Index | None: ...
    def difference(self, other: Index, sort: bool | None = None) -> Index: ...
    @property
    def is_all_dates(self) -> bool: ...
    def repeat(self, repeats: int) -> Index: ...
    def asof(self, label: Any) -> Scalar: ...
    def union(self, other: DataFrame | Series | Index | list, sort: bool | None = None) -> Index: ...
    def holds_integer(self) -> bool: ...
    def intersection(self, other: DataFrame | Series | Index | list) -> Index: ...
    def item(self) -> Scalar | tuple[Scalar, ...]: ...
    def insert(self, loc: int, item: Any) -> Index: ...
    def view(self) -> Index: ...
    def to_list(self) -> list: ...
    tolist = to_list
    @property
    def inferred_type(self) -> str: ...
    def __getattr__(self, item: str) -> Any: ...
    def __iter__(self) -> Iterator: ...
    def __and__(self, other: Index) -> Index: ...
    def __or__(self, other: Index) -> Index: ...
    def __xor__(self, other: Index) -> Index: ...
    def __rxor__(self, other: Any) -> Index: ...
    def __bool__(self) -> bool: ...

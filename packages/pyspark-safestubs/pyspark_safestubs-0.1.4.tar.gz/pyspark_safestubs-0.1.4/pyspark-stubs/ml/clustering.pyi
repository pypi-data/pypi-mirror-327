import numpy as np
from pyspark.ml._typing import M
from pyspark.ml.linalg import Matrix, Vector
from pyspark.ml.param.shared import HasAggregationDepth, HasCheckpointInterval, HasDistanceMeasure, HasFeaturesCol, HasMaxBlockSizeInMB, HasMaxIter, HasPredictionCol, HasProbabilityCol, HasSeed, HasSolver, HasTol, HasWeightCol, Param
from pyspark.ml.stat import MultivariateGaussian
from pyspark.ml.util import GeneralJavaMLWritable, HasTrainingSummary, JavaMLReadable, JavaMLWritable
from pyspark.ml.wrapper import JavaEstimator, JavaModel, JavaParams, JavaWrapper
from pyspark.sql import DataFrame
from typing import Any

__all__ = ['BisectingKMeans', 'BisectingKMeansModel', 'BisectingKMeansSummary', 'KMeans', 'KMeansModel', 'KMeansSummary', 'GaussianMixture', 'GaussianMixtureModel', 'GaussianMixtureSummary', 'LDA', 'LDAModel', 'LocalLDAModel', 'DistributedLDAModel', 'PowerIterationClustering']

class ClusteringSummary(JavaWrapper):
    @property
    def predictionCol(self) -> str: ...
    @property
    def predictions(self) -> DataFrame: ...
    @property
    def featuresCol(self) -> str: ...
    @property
    def k(self) -> int: ...
    @property
    def cluster(self) -> DataFrame: ...
    @property
    def clusterSizes(self) -> list[int]: ...
    @property
    def numIter(self) -> int: ...

class _GaussianMixtureParams(HasMaxIter, HasFeaturesCol, HasSeed, HasPredictionCol, HasProbabilityCol, HasTol, HasAggregationDepth, HasWeightCol):
    k: Param[int]
    def __init__(self, *args: Any) -> None: ...
    def getK(self) -> int: ...

class GaussianMixtureModel(JavaModel, _GaussianMixtureParams, JavaMLWritable, JavaMLReadable['GaussianMixtureModel'], HasTrainingSummary['GaussianMixtureSummary']):
    def setFeaturesCol(self, value: str) -> GaussianMixtureModel: ...
    def setPredictionCol(self, value: str) -> GaussianMixtureModel: ...
    def setProbabilityCol(self, value: str) -> GaussianMixtureModel: ...
    @property
    def weights(self) -> list[float]: ...
    @property
    def gaussians(self) -> list[MultivariateGaussian]: ...
    @property
    def gaussiansDF(self) -> DataFrame: ...
    @property
    def summary(self) -> GaussianMixtureSummary: ...
    def predict(self, value: Vector) -> int: ...
    def predictProbability(self, value: Vector) -> Vector: ...

class GaussianMixture(JavaEstimator[GaussianMixtureModel], _GaussianMixtureParams, JavaMLWritable, JavaMLReadable['GaussianMixture']):
    def __init__(self, *, featuresCol: str = 'features', predictionCol: str = 'prediction', k: int = 2, probabilityCol: str = 'probability', tol: float = 0.01, maxIter: int = 100, seed: int | None = None, aggregationDepth: int = 2, weightCol: str | None = None) -> None: ...
    def setParams(self, *, featuresCol: str = 'features', predictionCol: str = 'prediction', k: int = 2, probabilityCol: str = 'probability', tol: float = 0.01, maxIter: int = 100, seed: int | None = None, aggregationDepth: int = 2, weightCol: str | None = None) -> GaussianMixture: ...
    def setK(self, value: int) -> GaussianMixture: ...
    def setMaxIter(self, value: int) -> GaussianMixture: ...
    def setFeaturesCol(self, value: str) -> GaussianMixture: ...
    def setPredictionCol(self, value: str) -> GaussianMixture: ...
    def setProbabilityCol(self, value: str) -> GaussianMixture: ...
    def setWeightCol(self, value: str) -> GaussianMixture: ...
    def setSeed(self, value: int) -> GaussianMixture: ...
    def setTol(self, value: float) -> GaussianMixture: ...
    def setAggregationDepth(self, value: int) -> GaussianMixture: ...

class GaussianMixtureSummary(ClusteringSummary):
    @property
    def probabilityCol(self) -> str: ...
    @property
    def probability(self) -> DataFrame: ...
    @property
    def logLikelihood(self) -> float: ...

class KMeansSummary(ClusteringSummary):
    @property
    def trainingCost(self) -> float: ...

class _KMeansParams(HasMaxIter, HasFeaturesCol, HasSeed, HasPredictionCol, HasTol, HasDistanceMeasure, HasWeightCol, HasSolver, HasMaxBlockSizeInMB):
    k: Param[int]
    initMode: Param[str]
    initSteps: Param[int]
    solver: Param[str]
    def __init__(self, *args: Any) -> None: ...
    def getK(self) -> int: ...
    def getInitMode(self) -> str: ...
    def getInitSteps(self) -> int: ...

class KMeansModel(JavaModel, _KMeansParams, GeneralJavaMLWritable, JavaMLReadable['KMeansModel'], HasTrainingSummary['KMeansSummary']):
    def setFeaturesCol(self, value: str) -> KMeansModel: ...
    def setPredictionCol(self, value: str) -> KMeansModel: ...
    def clusterCenters(self) -> list[np.ndarray]: ...
    @property
    def summary(self) -> KMeansSummary: ...
    def predict(self, value: Vector) -> int: ...

class KMeans(JavaEstimator[KMeansModel], _KMeansParams, JavaMLWritable, JavaMLReadable['KMeans']):
    def __init__(self, *, featuresCol: str = 'features', predictionCol: str = 'prediction', k: int = 2, initMode: str = 'k-means||', initSteps: int = 2, tol: float = 0.0001, maxIter: int = 20, seed: int | None = None, distanceMeasure: str = 'euclidean', weightCol: str | None = None, solver: str = 'auto', maxBlockSizeInMB: float = 0.0) -> None: ...
    def setParams(self, *, featuresCol: str = 'features', predictionCol: str = 'prediction', k: int = 2, initMode: str = 'k-means||', initSteps: int = 2, tol: float = 0.0001, maxIter: int = 20, seed: int | None = None, distanceMeasure: str = 'euclidean', weightCol: str | None = None, solver: str = 'auto', maxBlockSizeInMB: float = 0.0) -> KMeans: ...
    def setK(self, value: int) -> KMeans: ...
    def setInitMode(self, value: str) -> KMeans: ...
    def setInitSteps(self, value: int) -> KMeans: ...
    def setDistanceMeasure(self, value: str) -> KMeans: ...
    def setMaxIter(self, value: int) -> KMeans: ...
    def setFeaturesCol(self, value: str) -> KMeans: ...
    def setPredictionCol(self, value: str) -> KMeans: ...
    def setSeed(self, value: int) -> KMeans: ...
    def setTol(self, value: float) -> KMeans: ...
    def setWeightCol(self, value: str) -> KMeans: ...
    def setSolver(self, value: str) -> KMeans: ...
    def setMaxBlockSizeInMB(self, value: float) -> KMeans: ...

class _BisectingKMeansParams(HasMaxIter, HasFeaturesCol, HasSeed, HasPredictionCol, HasDistanceMeasure, HasWeightCol):
    k: Param[int]
    minDivisibleClusterSize: Param[float]
    def __init__(self, *args: Any) -> None: ...
    def getK(self) -> int: ...
    def getMinDivisibleClusterSize(self) -> float: ...

class BisectingKMeansModel(JavaModel, _BisectingKMeansParams, JavaMLWritable, JavaMLReadable['BisectingKMeansModel'], HasTrainingSummary['BisectingKMeansSummary']):
    def setFeaturesCol(self, value: str) -> BisectingKMeansModel: ...
    def setPredictionCol(self, value: str) -> BisectingKMeansModel: ...
    def clusterCenters(self) -> list[np.ndarray]: ...
    def computeCost(self, dataset: DataFrame) -> float: ...
    @property
    def summary(self) -> BisectingKMeansSummary: ...
    def predict(self, value: Vector) -> int: ...

class BisectingKMeans(JavaEstimator[BisectingKMeansModel], _BisectingKMeansParams, JavaMLWritable, JavaMLReadable['BisectingKMeans']):
    def __init__(self, *, featuresCol: str = 'features', predictionCol: str = 'prediction', maxIter: int = 20, seed: int | None = None, k: int = 4, minDivisibleClusterSize: float = 1.0, distanceMeasure: str = 'euclidean', weightCol: str | None = None) -> None: ...
    def setParams(self, *, featuresCol: str = 'features', predictionCol: str = 'prediction', maxIter: int = 20, seed: int | None = None, k: int = 4, minDivisibleClusterSize: float = 1.0, distanceMeasure: str = 'euclidean', weightCol: str | None = None) -> BisectingKMeans: ...
    def setK(self, value: int) -> BisectingKMeans: ...
    def setMinDivisibleClusterSize(self, value: float) -> BisectingKMeans: ...
    def setDistanceMeasure(self, value: str) -> BisectingKMeans: ...
    def setMaxIter(self, value: int) -> BisectingKMeans: ...
    def setFeaturesCol(self, value: str) -> BisectingKMeans: ...
    def setPredictionCol(self, value: str) -> BisectingKMeans: ...
    def setSeed(self, value: int) -> BisectingKMeans: ...
    def setWeightCol(self, value: str) -> BisectingKMeans: ...

class BisectingKMeansSummary(ClusteringSummary):
    @property
    def trainingCost(self) -> float: ...

class _LDAParams(HasMaxIter, HasFeaturesCol, HasSeed, HasCheckpointInterval):
    k: Param[int]
    optimizer: Param[str]
    learningOffset: Param[float]
    learningDecay: Param[float]
    subsamplingRate: Param[float]
    optimizeDocConcentration: Param[bool]
    docConcentration: Param[list[float]]
    topicConcentration: Param[float]
    topicDistributionCol: Param[str]
    keepLastCheckpoint: Param[bool]
    def __init__(self, *args: Any) -> None: ...
    def getK(self) -> int: ...
    def getOptimizer(self) -> str: ...
    def getLearningOffset(self) -> float: ...
    def getLearningDecay(self) -> float: ...
    def getSubsamplingRate(self) -> float: ...
    def getOptimizeDocConcentration(self) -> bool: ...
    def getDocConcentration(self) -> list[float]: ...
    def getTopicConcentration(self) -> float: ...
    def getTopicDistributionCol(self) -> str: ...
    def getKeepLastCheckpoint(self) -> bool: ...

class LDAModel(JavaModel, _LDAParams):
    def setFeaturesCol(self, value: str) -> M: ...
    def setSeed(self, value: int) -> M: ...
    def setTopicDistributionCol(self, value: str) -> M: ...
    def isDistributed(self) -> bool: ...
    def vocabSize(self) -> int: ...
    def topicsMatrix(self) -> Matrix: ...
    def logLikelihood(self, dataset: DataFrame) -> float: ...
    def logPerplexity(self, dataset: DataFrame) -> float: ...
    def describeTopics(self, maxTermsPerTopic: int = 10) -> DataFrame: ...
    def estimatedDocConcentration(self) -> Vector: ...

class DistributedLDAModel(LDAModel, JavaMLReadable['DistributedLDAModel'], JavaMLWritable):
    def toLocal(self) -> LocalLDAModel: ...
    def trainingLogLikelihood(self) -> float: ...
    def logPrior(self) -> float: ...
    def getCheckpointFiles(self) -> list[str]: ...

class LocalLDAModel(LDAModel, JavaMLReadable['LocalLDAModel'], JavaMLWritable): ...

class LDA(JavaEstimator[LDAModel], _LDAParams, JavaMLReadable['LDA'], JavaMLWritable):
    def __init__(self, *, featuresCol: str = 'features', maxIter: int = 20, seed: int | None = None, checkpointInterval: int = 10, k: int = 10, optimizer: str = 'online', learningOffset: float = 1024.0, learningDecay: float = 0.51, subsamplingRate: float = 0.05, optimizeDocConcentration: bool = True, docConcentration: list[float] | None = None, topicConcentration: float | None = None, topicDistributionCol: str = 'topicDistribution', keepLastCheckpoint: bool = True) -> None: ...
    def setParams(self, *, featuresCol: str = 'features', maxIter: int = 20, seed: int | None = None, checkpointInterval: int = 10, k: int = 10, optimizer: str = 'online', learningOffset: float = 1024.0, learningDecay: float = 0.51, subsamplingRate: float = 0.05, optimizeDocConcentration: bool = True, docConcentration: list[float] | None = None, topicConcentration: float | None = None, topicDistributionCol: str = 'topicDistribution', keepLastCheckpoint: bool = True) -> LDA: ...
    def setCheckpointInterval(self, value: int) -> LDA: ...
    def setSeed(self, value: int) -> LDA: ...
    def setK(self, value: int) -> LDA: ...
    def setOptimizer(self, value: str) -> LDA: ...
    def setLearningOffset(self, value: float) -> LDA: ...
    def setLearningDecay(self, value: float) -> LDA: ...
    def setSubsamplingRate(self, value: float) -> LDA: ...
    def setOptimizeDocConcentration(self, value: bool) -> LDA: ...
    def setDocConcentration(self, value: list[float]) -> LDA: ...
    def setTopicConcentration(self, value: float) -> LDA: ...
    def setTopicDistributionCol(self, value: str) -> LDA: ...
    def setKeepLastCheckpoint(self, value: bool) -> LDA: ...
    def setMaxIter(self, value: int) -> LDA: ...
    def setFeaturesCol(self, value: str) -> LDA: ...

class _PowerIterationClusteringParams(HasMaxIter, HasWeightCol):
    k: Param[int]
    initMode: Param[str]
    srcCol: Param[str]
    dstCol: Param[str]
    def __init__(self, *args: Any) -> None: ...
    def getK(self) -> int: ...
    def getInitMode(self) -> str: ...
    def getSrcCol(self) -> str: ...
    def getDstCol(self) -> str: ...

class PowerIterationClustering(_PowerIterationClusteringParams, JavaParams, JavaMLReadable['PowerIterationClustering'], JavaMLWritable):
    def __init__(self, *, k: int = 2, maxIter: int = 20, initMode: str = 'random', srcCol: str = 'src', dstCol: str = 'dst', weightCol: str | None = None) -> None: ...
    def setParams(self, *, k: int = 2, maxIter: int = 20, initMode: str = 'random', srcCol: str = 'src', dstCol: str = 'dst', weightCol: str | None = None) -> PowerIterationClustering: ...
    def setK(self, value: int) -> PowerIterationClustering: ...
    def setInitMode(self, value: str) -> PowerIterationClustering: ...
    def setSrcCol(self, value: str) -> PowerIterationClustering: ...
    def setDstCol(self, value: str) -> PowerIterationClustering: ...
    def setMaxIter(self, value: int) -> PowerIterationClustering: ...
    def setWeightCol(self, value: str) -> PowerIterationClustering: ...
    def assignClusters(self, dataset: DataFrame) -> DataFrame: ...

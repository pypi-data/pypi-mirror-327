import abc
from _typeshed import Incomplete
from pyspark.ml.linalg import DenseMatrix, DenseVector, Vector
from pyspark.ml.param.shared import HasFeaturesCol, HasHandleInvalid, HasInputCol, HasInputCols, HasLabelCol, HasMaxIter, HasNumFeatures, HasOutputCol, HasOutputCols, HasRelativeError, HasSeed, HasStepSize, HasThreshold, HasThresholds, Param, Params
from pyspark.ml.util import JavaMLReadable, JavaMLWritable
from pyspark.ml.wrapper import JavaEstimator, JavaModel, JavaParams, JavaTransformer
from pyspark.sql.dataframe import DataFrame
from typing import Any, Generic, TypeVar, overload

__all__ = ['Binarizer', 'BucketedRandomProjectionLSH', 'BucketedRandomProjectionLSHModel', 'Bucketizer', 'ChiSqSelector', 'ChiSqSelectorModel', 'CountVectorizer', 'CountVectorizerModel', 'DCT', 'ElementwiseProduct', 'FeatureHasher', 'HashingTF', 'IDF', 'IDFModel', 'Imputer', 'ImputerModel', 'IndexToString', 'Interaction', 'MaxAbsScaler', 'MaxAbsScalerModel', 'MinHashLSH', 'MinHashLSHModel', 'MinMaxScaler', 'MinMaxScalerModel', 'NGram', 'Normalizer', 'OneHotEncoder', 'OneHotEncoderModel', 'PCA', 'PCAModel', 'PolynomialExpansion', 'QuantileDiscretizer', 'RobustScaler', 'RobustScalerModel', 'RegexTokenizer', 'RFormula', 'RFormulaModel', 'SQLTransformer', 'StandardScaler', 'StandardScalerModel', 'StopWordsRemover', 'StringIndexer', 'StringIndexerModel', 'Tokenizer', 'UnivariateFeatureSelector', 'UnivariateFeatureSelectorModel', 'VarianceThresholdSelector', 'VarianceThresholdSelectorModel', 'VectorAssembler', 'VectorIndexer', 'VectorIndexerModel', 'VectorSizeHint', 'VectorSlicer', 'Word2Vec', 'Word2VecModel']

JM = TypeVar('JM', bound=JavaTransformer)
P = TypeVar('P', bound=Params)

class Binarizer(JavaTransformer, HasThreshold, HasThresholds, HasInputCol, HasOutputCol, HasInputCols, HasOutputCols, JavaMLReadable['Binarizer'], JavaMLWritable):
    threshold: Param[float]
    thresholds: Param[list[float]]
    @overload
    def __init__(self, *, threshold: float = ..., inputCol: str | None = ..., outputCol: str | None = ...) -> None: ...
    @overload
    def __init__(self, *, thresholds: list[float] | None = ..., inputCols: list[str] | None = ..., outputCols: list[str] | None = ...) -> None: ...
    @overload
    def setParams(self, *, threshold: float = ..., inputCol: str | None = ..., outputCol: str | None = ...) -> Binarizer: ...
    @overload
    def setParams(self, *, thresholds: list[float] | None = ..., inputCols: list[str] | None = ..., outputCols: list[str] | None = ...) -> Binarizer: ...
    def setThreshold(self, value: float) -> Binarizer: ...
    def setThresholds(self, value: list[float]) -> Binarizer: ...
    def setInputCol(self, value: str) -> Binarizer: ...
    def setInputCols(self, value: list[str]) -> Binarizer: ...
    def setOutputCol(self, value: str) -> Binarizer: ...
    def setOutputCols(self, value: list[str]) -> Binarizer: ...

class _LSHParams(HasInputCol, HasOutputCol):
    numHashTables: Param[int]
    def __init__(self, *args: Any) -> None: ...
    def getNumHashTables(self) -> int: ...

class _LSH(JavaEstimator[JM], _LSHParams, JavaMLReadable, JavaMLWritable, Generic[JM], metaclass=abc.ABCMeta):
    def setNumHashTables(self, value: int) -> P: ...
    def setInputCol(self, value: str) -> P: ...
    def setOutputCol(self, value: str) -> P: ...

class _LSHModel(JavaModel, _LSHParams):
    def setInputCol(self, value: str) -> P: ...
    def setOutputCol(self, value: str) -> P: ...
    def approxNearestNeighbors(self, dataset: DataFrame, key: Vector, numNearestNeighbors: int, distCol: str = 'distCol') -> DataFrame: ...
    def approxSimilarityJoin(self, datasetA: DataFrame, datasetB: DataFrame, threshold: float, distCol: str = 'distCol') -> DataFrame: ...

class _BucketedRandomProjectionLSHParams:
    bucketLength: Param[float]
    def getBucketLength(self) -> float: ...

class BucketedRandomProjectionLSH(_LSH['BucketedRandomProjectionLSHModel'], _LSHParams, _BucketedRandomProjectionLSHParams, HasSeed, JavaMLReadable['BucketedRandomProjectionLSH'], JavaMLWritable):
    def __init__(self, *, inputCol: str | None = None, outputCol: str | None = None, seed: int | None = None, numHashTables: int = 1, bucketLength: float | None = None) -> None: ...
    def setParams(self, *, inputCol: str | None = None, outputCol: str | None = None, seed: int | None = None, numHashTables: int = 1, bucketLength: float | None = None) -> BucketedRandomProjectionLSH: ...
    def setBucketLength(self, value: float) -> BucketedRandomProjectionLSH: ...
    def setSeed(self, value: int) -> BucketedRandomProjectionLSH: ...

class BucketedRandomProjectionLSHModel(_LSHModel, _BucketedRandomProjectionLSHParams, JavaMLReadable['BucketedRandomProjectionLSHModel'], JavaMLWritable): ...

class Bucketizer(JavaTransformer, HasInputCol, HasOutputCol, HasInputCols, HasOutputCols, HasHandleInvalid, JavaMLReadable['Bucketizer'], JavaMLWritable):
    splits: Param[list[float]]
    handleInvalid: Param[str]
    splitsArray: Param[list[list[float]]]
    @overload
    def __init__(self, *, splits: list[float] | None = ..., inputCol: str | None = ..., outputCol: str | None = ..., handleInvalid: str = ...) -> None: ...
    @overload
    def __init__(self, *, handleInvalid: str = ..., splitsArray: list[list[float]] | None = ..., inputCols: list[str] | None = ..., outputCols: list[str] | None = ...) -> None: ...
    @overload
    def setParams(self, *, splits: list[float] | None = ..., inputCol: str | None = ..., outputCol: str | None = ..., handleInvalid: str = ...) -> Bucketizer: ...
    @overload
    def setParams(self, *, handleInvalid: str = ..., splitsArray: list[list[float]] | None = ..., inputCols: list[str] | None = ..., outputCols: list[str] | None = ...) -> Bucketizer: ...
    def setSplits(self, value: list[float]) -> Bucketizer: ...
    def getSplits(self) -> list[float]: ...
    def setSplitsArray(self, value: list[list[float]]) -> Bucketizer: ...
    def getSplitsArray(self) -> list[list[float]]: ...
    def setInputCol(self, value: str) -> Bucketizer: ...
    def setInputCols(self, value: list[str]) -> Bucketizer: ...
    def setOutputCol(self, value: str) -> Bucketizer: ...
    def setOutputCols(self, value: list[str]) -> Bucketizer: ...
    def setHandleInvalid(self, value: str) -> Bucketizer: ...

class _CountVectorizerParams(JavaParams, HasInputCol, HasOutputCol):
    minTF: Param[float]
    minDF: Param[float]
    maxDF: Param[float]
    vocabSize: Param[int]
    binary: Param[bool]
    def __init__(self, *args: Any) -> None: ...
    def getMinTF(self) -> float: ...
    def getMinDF(self) -> float: ...
    def getMaxDF(self) -> float: ...
    def getVocabSize(self) -> int: ...
    def getBinary(self) -> bool: ...

class CountVectorizer(JavaEstimator['CountVectorizerModel'], _CountVectorizerParams, JavaMLReadable['CountVectorizer'], JavaMLWritable):
    def __init__(self, *, minTF: float = 1.0, minDF: float = 1.0, maxDF: float = ..., vocabSize: int = ..., binary: bool = False, inputCol: str | None = None, outputCol: str | None = None) -> None: ...
    def setParams(self, *, minTF: float = 1.0, minDF: float = 1.0, maxDF: float = ..., vocabSize: int = ..., binary: bool = False, inputCol: str | None = None, outputCol: str | None = None) -> CountVectorizer: ...
    def setMinTF(self, value: float) -> CountVectorizer: ...
    def setMinDF(self, value: float) -> CountVectorizer: ...
    def setMaxDF(self, value: float) -> CountVectorizer: ...
    def setVocabSize(self, value: int) -> CountVectorizer: ...
    def setBinary(self, value: bool) -> CountVectorizer: ...
    def setInputCol(self, value: str) -> CountVectorizer: ...
    def setOutputCol(self, value: str) -> CountVectorizer: ...

class CountVectorizerModel(JavaModel, _CountVectorizerParams, JavaMLReadable['CountVectorizerModel'], JavaMLWritable):
    def setInputCol(self, value: str) -> CountVectorizerModel: ...
    def setOutputCol(self, value: str) -> CountVectorizerModel: ...
    @classmethod
    def from_vocabulary(cls, vocabulary: list[str], inputCol: str, outputCol: str | None = None, minTF: float | None = None, binary: bool | None = None) -> CountVectorizerModel: ...
    @property
    def vocabulary(self) -> list[str]: ...
    def setMinTF(self, value: float) -> CountVectorizerModel: ...
    def setBinary(self, value: bool) -> CountVectorizerModel: ...

class DCT(JavaTransformer, HasInputCol, HasOutputCol, JavaMLReadable['DCT'], JavaMLWritable):
    inverse: Param[bool]
    def __init__(self, *, inverse: bool = False, inputCol: str | None = None, outputCol: str | None = None) -> None: ...
    def setParams(self, *, inverse: bool = False, inputCol: str | None = None, outputCol: str | None = None) -> DCT: ...
    def setInverse(self, value: bool) -> DCT: ...
    def getInverse(self) -> bool: ...
    def setInputCol(self, value: str) -> DCT: ...
    def setOutputCol(self, value: str) -> DCT: ...

class ElementwiseProduct(JavaTransformer, HasInputCol, HasOutputCol, JavaMLReadable['ElementwiseProduct'], JavaMLWritable):
    scalingVec: Param[Vector]
    def __init__(self, *, scalingVec: Vector | None = None, inputCol: str | None = None, outputCol: str | None = None) -> None: ...
    def setParams(self, *, scalingVec: Vector | None = None, inputCol: str | None = None, outputCol: str | None = None) -> ElementwiseProduct: ...
    def setScalingVec(self, value: Vector) -> ElementwiseProduct: ...
    def getScalingVec(self) -> Vector: ...
    def setInputCol(self, value: str) -> ElementwiseProduct: ...
    def setOutputCol(self, value: str) -> ElementwiseProduct: ...

class FeatureHasher(JavaTransformer, HasInputCols, HasOutputCol, HasNumFeatures, JavaMLReadable['FeatureHasher'], JavaMLWritable):
    categoricalCols: Param[list[str]]
    def __init__(self, *, numFeatures: int = ..., inputCols: list[str] | None = None, outputCol: str | None = None, categoricalCols: list[str] | None = None) -> None: ...
    def setParams(self, *, numFeatures: int = ..., inputCols: list[str] | None = None, outputCol: str | None = None, categoricalCols: list[str] | None = None) -> FeatureHasher: ...
    def setCategoricalCols(self, value: list[str]) -> FeatureHasher: ...
    def getCategoricalCols(self) -> list[str]: ...
    def setInputCols(self, value: list[str]) -> FeatureHasher: ...
    def setOutputCol(self, value: str) -> FeatureHasher: ...
    def setNumFeatures(self, value: int) -> FeatureHasher: ...

class HashingTF(JavaTransformer, HasInputCol, HasOutputCol, HasNumFeatures, JavaMLReadable['HashingTF'], JavaMLWritable):
    binary: Param[bool]
    def __init__(self, *, numFeatures: int = ..., binary: bool = False, inputCol: str | None = None, outputCol: str | None = None) -> None: ...
    def setParams(self, *, numFeatures: int = ..., binary: bool = False, inputCol: str | None = None, outputCol: str | None = None) -> HashingTF: ...
    def setBinary(self, value: bool) -> HashingTF: ...
    def getBinary(self) -> bool: ...
    def setInputCol(self, value: str) -> HashingTF: ...
    def setOutputCol(self, value: str) -> HashingTF: ...
    def setNumFeatures(self, value: int) -> HashingTF: ...
    def indexOf(self, term: Any) -> int: ...

class _IDFParams(HasInputCol, HasOutputCol):
    minDocFreq: Param[int]
    def getMinDocFreq(self) -> int: ...
    def __init__(self, *args: Any) -> None: ...

class IDF(JavaEstimator['IDFModel'], _IDFParams, JavaMLReadable['IDF'], JavaMLWritable):
    def __init__(self, *, minDocFreq: int = 0, inputCol: str | None = None, outputCol: str | None = None) -> None: ...
    def setParams(self, *, minDocFreq: int = 0, inputCol: str | None = None, outputCol: str | None = None) -> IDF: ...
    def setMinDocFreq(self, value: int) -> IDF: ...
    def setInputCol(self, value: str) -> IDF: ...
    def setOutputCol(self, value: str) -> IDF: ...

class IDFModel(JavaModel, _IDFParams, JavaMLReadable['IDFModel'], JavaMLWritable):
    def setInputCol(self, value: str) -> IDFModel: ...
    def setOutputCol(self, value: str) -> IDFModel: ...
    @property
    def idf(self) -> Vector: ...
    @property
    def docFreq(self) -> list[int]: ...
    @property
    def numDocs(self) -> int: ...

class _ImputerParams(HasInputCol, HasInputCols, HasOutputCol, HasOutputCols, HasRelativeError):
    strategy: Param[str]
    missingValue: Param[float]
    def __init__(self, *args: Any) -> None: ...
    def getStrategy(self) -> str: ...
    def getMissingValue(self) -> float: ...

class Imputer(JavaEstimator['ImputerModel'], _ImputerParams, JavaMLReadable['Imputer'], JavaMLWritable):
    @overload
    def __init__(self, *, strategy: str = ..., missingValue: float = ..., inputCols: list[str] | None = ..., outputCols: list[str] | None = ..., relativeError: float = ...) -> None: ...
    @overload
    def __init__(self, *, strategy: str = ..., missingValue: float = ..., inputCol: str | None = ..., outputCol: str | None = ..., relativeError: float = ...) -> None: ...
    @overload
    def setParams(self, *, strategy: str = ..., missingValue: float = ..., inputCols: list[str] | None = ..., outputCols: list[str] | None = ..., relativeError: float = ...) -> Imputer: ...
    @overload
    def setParams(self, *, strategy: str = ..., missingValue: float = ..., inputCol: str | None = ..., outputCol: str | None = ..., relativeError: float = ...) -> Imputer: ...
    def setStrategy(self, value: str) -> Imputer: ...
    def setMissingValue(self, value: float) -> Imputer: ...
    def setInputCols(self, value: list[str]) -> Imputer: ...
    def setOutputCols(self, value: list[str]) -> Imputer: ...
    def setInputCol(self, value: str) -> Imputer: ...
    def setOutputCol(self, value: str) -> Imputer: ...
    def setRelativeError(self, value: float) -> Imputer: ...

class ImputerModel(JavaModel, _ImputerParams, JavaMLReadable['ImputerModel'], JavaMLWritable):
    def setInputCols(self, value: list[str]) -> ImputerModel: ...
    def setOutputCols(self, value: list[str]) -> ImputerModel: ...
    def setInputCol(self, value: str) -> ImputerModel: ...
    def setOutputCol(self, value: str) -> ImputerModel: ...
    @property
    def surrogateDF(self) -> DataFrame: ...

class Interaction(JavaTransformer, HasInputCols, HasOutputCol, JavaMLReadable['Interaction'], JavaMLWritable):
    def __init__(self, *, inputCols: list[str] | None = None, outputCol: str | None = None) -> None: ...
    def setParams(self, *, inputCols: list[str] | None = None, outputCol: str | None = None) -> Interaction: ...
    def setInputCols(self, value: list[str]) -> Interaction: ...
    def setOutputCol(self, value: str) -> Interaction: ...

class _MaxAbsScalerParams(HasInputCol, HasOutputCol): ...

class MaxAbsScaler(JavaEstimator['MaxAbsScalerModel'], _MaxAbsScalerParams, JavaMLReadable['MaxAbsScaler'], JavaMLWritable):
    def __init__(self, *, inputCol: str | None = None, outputCol: str | None = None) -> None: ...
    def setParams(self, *, inputCol: str | None = None, outputCol: str | None = None) -> MaxAbsScaler: ...
    def setInputCol(self, value: str) -> MaxAbsScaler: ...
    def setOutputCol(self, value: str) -> MaxAbsScaler: ...

class MaxAbsScalerModel(JavaModel, _MaxAbsScalerParams, JavaMLReadable['MaxAbsScalerModel'], JavaMLWritable):
    def setInputCol(self, value: str) -> MaxAbsScalerModel: ...
    def setOutputCol(self, value: str) -> MaxAbsScalerModel: ...
    @property
    def maxAbs(self) -> Vector: ...

class MinHashLSH(_LSH['MinHashLSHModel'], HasInputCol, HasOutputCol, HasSeed, JavaMLReadable['MinHashLSH'], JavaMLWritable):
    def __init__(self, *, inputCol: str | None = None, outputCol: str | None = None, seed: int | None = None, numHashTables: int = 1) -> None: ...
    def setParams(self, *, inputCol: str | None = None, outputCol: str | None = None, seed: int | None = None, numHashTables: int = 1) -> MinHashLSH: ...
    def setSeed(self, value: int) -> MinHashLSH: ...

class MinHashLSHModel(_LSHModel, JavaMLReadable, JavaMLWritable): ...

class _MinMaxScalerParams(HasInputCol, HasOutputCol):
    min: Param[float]
    max: Param[float]
    def __init__(self, *args: Any) -> None: ...
    def getMin(self) -> float: ...
    def getMax(self) -> float: ...

class MinMaxScaler(JavaEstimator['MinMaxScalerModel'], _MinMaxScalerParams, JavaMLReadable['MinMaxScaler'], JavaMLWritable):
    def __init__(self, *, min: float = 0.0, max: float = 1.0, inputCol: str | None = None, outputCol: str | None = None) -> None: ...
    def setParams(self, *, min: float = 0.0, max: float = 1.0, inputCol: str | None = None, outputCol: str | None = None) -> MinMaxScaler: ...
    def setMin(self, value: float) -> MinMaxScaler: ...
    def setMax(self, value: float) -> MinMaxScaler: ...
    def setInputCol(self, value: str) -> MinMaxScaler: ...
    def setOutputCol(self, value: str) -> MinMaxScaler: ...

class MinMaxScalerModel(JavaModel, _MinMaxScalerParams, JavaMLReadable['MinMaxScalerModel'], JavaMLWritable):
    def setInputCol(self, value: str) -> MinMaxScalerModel: ...
    def setOutputCol(self, value: str) -> MinMaxScalerModel: ...
    def setMin(self, value: float) -> MinMaxScalerModel: ...
    def setMax(self, value: float) -> MinMaxScalerModel: ...
    @property
    def originalMin(self) -> Vector: ...
    @property
    def originalMax(self) -> Vector: ...

class NGram(JavaTransformer, HasInputCol, HasOutputCol, JavaMLReadable['NGram'], JavaMLWritable):
    n: Param[int]
    def __init__(self, *, n: int = 2, inputCol: str | None = None, outputCol: str | None = None) -> None: ...
    def setParams(self, *, n: int = 2, inputCol: str | None = None, outputCol: str | None = None) -> NGram: ...
    def setN(self, value: int) -> NGram: ...
    def getN(self) -> int: ...
    def setInputCol(self, value: str) -> NGram: ...
    def setOutputCol(self, value: str) -> NGram: ...

class Normalizer(JavaTransformer, HasInputCol, HasOutputCol, JavaMLReadable['Normalizer'], JavaMLWritable):
    p: Incomplete
    def __init__(self, *, p: float = 2.0, inputCol: str | None = None, outputCol: str | None = None) -> None: ...
    def setParams(self, *, p: float = 2.0, inputCol: str | None = None, outputCol: str | None = None) -> Normalizer: ...
    def setP(self, value: float) -> Normalizer: ...
    def getP(self) -> float: ...
    def setInputCol(self, value: str) -> Normalizer: ...
    def setOutputCol(self, value: str) -> Normalizer: ...

class _OneHotEncoderParams(HasInputCol, HasInputCols, HasOutputCol, HasOutputCols, HasHandleInvalid):
    handleInvalid: Param[str]
    dropLast: Param[bool]
    def __init__(self, *args: Any) -> None: ...
    def getDropLast(self) -> bool: ...

class OneHotEncoder(JavaEstimator['OneHotEncoderModel'], _OneHotEncoderParams, JavaMLReadable['OneHotEncoder'], JavaMLWritable):
    @overload
    def __init__(self, *, inputCols: list[str] | None = ..., outputCols: list[str] | None = ..., handleInvalid: str = ..., dropLast: bool = ...) -> None: ...
    @overload
    def __init__(self, *, handleInvalid: str = ..., dropLast: bool = ..., inputCol: str | None = ..., outputCol: str | None = ...) -> None: ...
    @overload
    def setParams(self, *, inputCols: list[str] | None = ..., outputCols: list[str] | None = ..., handleInvalid: str = ..., dropLast: bool = ...) -> OneHotEncoder: ...
    @overload
    def setParams(self, *, handleInvalid: str = ..., dropLast: bool = ..., inputCol: str | None = ..., outputCol: str | None = ...) -> OneHotEncoder: ...
    def setDropLast(self, value: bool) -> OneHotEncoder: ...
    def setInputCols(self, value: list[str]) -> OneHotEncoder: ...
    def setOutputCols(self, value: list[str]) -> OneHotEncoder: ...
    def setHandleInvalid(self, value: str) -> OneHotEncoder: ...
    def setInputCol(self, value: str) -> OneHotEncoder: ...
    def setOutputCol(self, value: str) -> OneHotEncoder: ...

class OneHotEncoderModel(JavaModel, _OneHotEncoderParams, JavaMLReadable['OneHotEncoderModel'], JavaMLWritable):
    def setDropLast(self, value: bool) -> OneHotEncoderModel: ...
    def setInputCols(self, value: list[str]) -> OneHotEncoderModel: ...
    def setOutputCols(self, value: list[str]) -> OneHotEncoderModel: ...
    def setInputCol(self, value: str) -> OneHotEncoderModel: ...
    def setOutputCol(self, value: str) -> OneHotEncoderModel: ...
    def setHandleInvalid(self, value: str) -> OneHotEncoderModel: ...
    @property
    def categorySizes(self) -> list[int]: ...

class PolynomialExpansion(JavaTransformer, HasInputCol, HasOutputCol, JavaMLReadable['PolynomialExpansion'], JavaMLWritable):
    degree: Param[int]
    def __init__(self, *, degree: int = 2, inputCol: str | None = None, outputCol: str | None = None) -> None: ...
    def setParams(self, *, degree: int = 2, inputCol: str | None = None, outputCol: str | None = None) -> PolynomialExpansion: ...
    def setDegree(self, value: int) -> PolynomialExpansion: ...
    def getDegree(self) -> int: ...
    def setInputCol(self, value: str) -> PolynomialExpansion: ...
    def setOutputCol(self, value: str) -> PolynomialExpansion: ...

class QuantileDiscretizer(JavaEstimator, HasInputCol, HasOutputCol, HasInputCols, HasOutputCols, HasHandleInvalid, HasRelativeError, JavaMLReadable['QuantileDiscretizer'], JavaMLWritable):
    numBuckets: Param[int]
    handleInvalid: Param[str]
    numBucketsArray: Param[list[int]]
    @overload
    def __init__(self, *, numBuckets: int = ..., inputCol: str | None = ..., outputCol: str | None = ..., relativeError: float = ..., handleInvalid: str = ...) -> None: ...
    @overload
    def __init__(self, *, relativeError: float = ..., handleInvalid: str = ..., numBucketsArray: list[int] | None = ..., inputCols: list[str] | None = ..., outputCols: list[str] | None = ...) -> None: ...
    @overload
    def setParams(self, *, numBuckets: int = ..., inputCol: str | None = ..., outputCol: str | None = ..., relativeError: float = ..., handleInvalid: str = ...) -> QuantileDiscretizer: ...
    @overload
    def setParams(self, *, relativeError: float = ..., handleInvalid: str = ..., numBucketsArray: list[int] | None = ..., inputCols: list[str] | None = ..., outputCols: list[str] | None = ...) -> QuantileDiscretizer: ...
    def setNumBuckets(self, value: int) -> QuantileDiscretizer: ...
    def getNumBuckets(self) -> int: ...
    def setNumBucketsArray(self, value: list[int]) -> QuantileDiscretizer: ...
    def getNumBucketsArray(self) -> list[int]: ...
    def setRelativeError(self, value: float) -> QuantileDiscretizer: ...
    def setInputCol(self, value: str) -> QuantileDiscretizer: ...
    def setInputCols(self, value: list[str]) -> QuantileDiscretizer: ...
    def setOutputCol(self, value: str) -> QuantileDiscretizer: ...
    def setOutputCols(self, value: list[str]) -> QuantileDiscretizer: ...
    def setHandleInvalid(self, value: str) -> QuantileDiscretizer: ...

class _RobustScalerParams(HasInputCol, HasOutputCol, HasRelativeError):
    lower: Param[float]
    upper: Param[float]
    withCentering: Param[bool]
    withScaling: Param[bool]
    def __init__(self, *args: Any) -> None: ...
    def getLower(self) -> float: ...
    def getUpper(self) -> float: ...
    def getWithCentering(self) -> bool: ...
    def getWithScaling(self) -> bool: ...

class RobustScaler(JavaEstimator, _RobustScalerParams, JavaMLReadable['RobustScaler'], JavaMLWritable):
    def __init__(self, *, lower: float = 0.25, upper: float = 0.75, withCentering: bool = False, withScaling: bool = True, inputCol: str | None = None, outputCol: str | None = None, relativeError: float = 0.001) -> None: ...
    def setParams(self, *, lower: float = 0.25, upper: float = 0.75, withCentering: bool = False, withScaling: bool = True, inputCol: str | None = None, outputCol: str | None = None, relativeError: float = 0.001) -> RobustScaler: ...
    def setLower(self, value: float) -> RobustScaler: ...
    def setUpper(self, value: float) -> RobustScaler: ...
    def setWithCentering(self, value: bool) -> RobustScaler: ...
    def setWithScaling(self, value: bool) -> RobustScaler: ...
    def setInputCol(self, value: str) -> RobustScaler: ...
    def setOutputCol(self, value: str) -> RobustScaler: ...
    def setRelativeError(self, value: float) -> RobustScaler: ...

class RobustScalerModel(JavaModel, _RobustScalerParams, JavaMLReadable['RobustScalerModel'], JavaMLWritable):
    def setInputCol(self, value: str) -> RobustScalerModel: ...
    def setOutputCol(self, value: str) -> RobustScalerModel: ...
    @property
    def median(self) -> Vector: ...
    @property
    def range(self) -> Vector: ...

class RegexTokenizer(JavaTransformer, HasInputCol, HasOutputCol, JavaMLReadable['RegexTokenizer'], JavaMLWritable):
    minTokenLength: Param[int]
    gaps: Param[bool]
    pattern: Param[str]
    toLowercase: Param[bool]
    def __init__(self, *, minTokenLength: int = 1, gaps: bool = True, pattern: str = '\\s+', inputCol: str | None = None, outputCol: str | None = None, toLowercase: bool = True) -> None: ...
    def setParams(self, *, minTokenLength: int = 1, gaps: bool = True, pattern: str = '\\s+', inputCol: str | None = None, outputCol: str | None = None, toLowercase: bool = True) -> RegexTokenizer: ...
    def setMinTokenLength(self, value: int) -> RegexTokenizer: ...
    def getMinTokenLength(self) -> int: ...
    def setGaps(self, value: bool) -> RegexTokenizer: ...
    def getGaps(self) -> bool: ...
    def setPattern(self, value: str) -> RegexTokenizer: ...
    def getPattern(self) -> str: ...
    def setToLowercase(self, value: bool) -> RegexTokenizer: ...
    def getToLowercase(self) -> bool: ...
    def setInputCol(self, value: str) -> RegexTokenizer: ...
    def setOutputCol(self, value: str) -> RegexTokenizer: ...

class SQLTransformer(JavaTransformer, JavaMLReadable['SQLTransformer'], JavaMLWritable):
    statement: Incomplete
    def __init__(self, *, statement: str | None = None) -> None: ...
    def setParams(self, *, statement: str | None = None) -> SQLTransformer: ...
    def setStatement(self, value: str) -> SQLTransformer: ...
    def getStatement(self) -> str: ...

class _StandardScalerParams(HasInputCol, HasOutputCol):
    withMean: Param[bool]
    withStd: Param[bool]
    def __init__(self, *args: Any) -> None: ...
    def getWithMean(self) -> bool: ...
    def getWithStd(self) -> bool: ...

class StandardScaler(JavaEstimator['StandardScalerModel'], _StandardScalerParams, JavaMLReadable['StandardScaler'], JavaMLWritable):
    def __init__(self, *, withMean: bool = False, withStd: bool = True, inputCol: str | None = None, outputCol: str | None = None) -> None: ...
    def setParams(self, *, withMean: bool = False, withStd: bool = True, inputCol: str | None = None, outputCol: str | None = None) -> StandardScaler: ...
    def setWithMean(self, value: bool) -> StandardScaler: ...
    def setWithStd(self, value: bool) -> StandardScaler: ...
    def setInputCol(self, value: str) -> StandardScaler: ...
    def setOutputCol(self, value: str) -> StandardScaler: ...

class StandardScalerModel(JavaModel, _StandardScalerParams, JavaMLReadable['StandardScalerModel'], JavaMLWritable):
    def setInputCol(self, value: str) -> StandardScalerModel: ...
    def setOutputCol(self, value: str) -> StandardScalerModel: ...
    @property
    def std(self) -> Vector: ...
    @property
    def mean(self) -> Vector: ...

class _StringIndexerParams(JavaParams, HasHandleInvalid, HasInputCol, HasOutputCol, HasInputCols, HasOutputCols):
    stringOrderType: Param[str]
    handleInvalid: Param[str]
    def __init__(self, *args: Any) -> None: ...
    def getStringOrderType(self) -> str: ...

class StringIndexer(JavaEstimator['StringIndexerModel'], _StringIndexerParams, JavaMLReadable['StringIndexer'], JavaMLWritable):
    @overload
    def __init__(self, *, inputCol: str | None = ..., outputCol: str | None = ..., handleInvalid: str = ..., stringOrderType: str = ...) -> None: ...
    @overload
    def __init__(self, *, inputCols: list[str] | None = ..., outputCols: list[str] | None = ..., handleInvalid: str = ..., stringOrderType: str = ...) -> None: ...
    @overload
    def setParams(self, *, inputCol: str | None = ..., outputCol: str | None = ..., handleInvalid: str = ..., stringOrderType: str = ...) -> StringIndexer: ...
    @overload
    def setParams(self, *, inputCols: list[str] | None = ..., outputCols: list[str] | None = ..., handleInvalid: str = ..., stringOrderType: str = ...) -> StringIndexer: ...
    def setStringOrderType(self, value: str) -> StringIndexer: ...
    def setInputCol(self, value: str) -> StringIndexer: ...
    def setInputCols(self, value: list[str]) -> StringIndexer: ...
    def setOutputCol(self, value: str) -> StringIndexer: ...
    def setOutputCols(self, value: list[str]) -> StringIndexer: ...
    def setHandleInvalid(self, value: str) -> StringIndexer: ...

class StringIndexerModel(JavaModel, _StringIndexerParams, JavaMLReadable['StringIndexerModel'], JavaMLWritable):
    def setInputCol(self, value: str) -> StringIndexerModel: ...
    def setInputCols(self, value: list[str]) -> StringIndexerModel: ...
    def setOutputCol(self, value: str) -> StringIndexerModel: ...
    def setOutputCols(self, value: list[str]) -> StringIndexerModel: ...
    def setHandleInvalid(self, value: str) -> StringIndexerModel: ...
    @classmethod
    def from_labels(cls, labels: list[str], inputCol: str, outputCol: str | None = None, handleInvalid: str | None = None) -> StringIndexerModel: ...
    @classmethod
    def from_arrays_of_labels(cls, arrayOfLabels: list[list[str]], inputCols: list[str], outputCols: list[str] | None = None, handleInvalid: str | None = None) -> StringIndexerModel: ...
    @property
    def labels(self) -> list[str]: ...
    @property
    def labelsArray(self) -> list[str]: ...

class IndexToString(JavaTransformer, HasInputCol, HasOutputCol, JavaMLReadable['IndexToString'], JavaMLWritable):
    labels: Param[list[str]]
    def __init__(self, *, inputCol: str | None = None, outputCol: str | None = None, labels: list[str] | None = None) -> None: ...
    def setParams(self, *, inputCol: str | None = None, outputCol: str | None = None, labels: list[str] | None = None) -> IndexToString: ...
    def setLabels(self, value: list[str]) -> IndexToString: ...
    def getLabels(self) -> list[str]: ...
    def setInputCol(self, value: str) -> IndexToString: ...
    def setOutputCol(self, value: str) -> IndexToString: ...

class StopWordsRemover(JavaTransformer, HasInputCol, HasOutputCol, HasInputCols, HasOutputCols, JavaMLReadable['StopWordsRemover'], JavaMLWritable):
    stopWords: Param[list[str]]
    caseSensitive: Param[bool]
    locale: Param[str]
    @overload
    def __init__(self, *, inputCol: str | None = ..., outputCol: str | None = ..., stopWords: list[str] | None = ..., caseSensitive: bool = ..., locale: str | None = ...) -> None: ...
    @overload
    def __init__(self, *, stopWords: list[str] | None = ..., caseSensitive: bool = ..., locale: str | None = ..., inputCols: list[str] | None = ..., outputCols: list[str] | None = ...) -> None: ...
    @overload
    def setParams(self, *, inputCol: str | None = ..., outputCol: str | None = ..., stopWords: list[str] | None = ..., caseSensitive: bool = ..., locale: str | None = ...) -> StopWordsRemover: ...
    @overload
    def setParams(self, *, stopWords: list[str] | None = ..., caseSensitive: bool = ..., locale: str | None = ..., inputCols: list[str] | None = ..., outputCols: list[str] | None = ...) -> StopWordsRemover: ...
    def setStopWords(self, value: list[str]) -> StopWordsRemover: ...
    def getStopWords(self) -> list[str]: ...
    def setCaseSensitive(self, value: bool) -> StopWordsRemover: ...
    def getCaseSensitive(self) -> bool: ...
    def setLocale(self, value: str) -> StopWordsRemover: ...
    def getLocale(self) -> str: ...
    def setInputCol(self, value: str) -> StopWordsRemover: ...
    def setOutputCol(self, value: str) -> StopWordsRemover: ...
    def setInputCols(self, value: list[str]) -> StopWordsRemover: ...
    def setOutputCols(self, value: list[str]) -> StopWordsRemover: ...
    @staticmethod
    def loadDefaultStopWords(language: str) -> list[str]: ...

class Tokenizer(JavaTransformer, HasInputCol, HasOutputCol, JavaMLReadable['Tokenizer'], JavaMLWritable):
    def __init__(self, *, inputCol: str | None = None, outputCol: str | None = None) -> None: ...
    def setParams(self, *, inputCol: str | None = None, outputCol: str | None = None) -> Tokenizer: ...
    def setInputCol(self, value: str) -> Tokenizer: ...
    def setOutputCol(self, value: str) -> Tokenizer: ...

class VectorAssembler(JavaTransformer, HasInputCols, HasOutputCol, HasHandleInvalid, JavaMLReadable['VectorAssembler'], JavaMLWritable):
    handleInvalid: Param[str]
    def __init__(self, *, inputCols: list[str] | None = None, outputCol: str | None = None, handleInvalid: str = 'error') -> None: ...
    def setParams(self, *, inputCols: list[str] | None = None, outputCol: str | None = None, handleInvalid: str = 'error') -> VectorAssembler: ...
    def setInputCols(self, value: list[str]) -> VectorAssembler: ...
    def setOutputCol(self, value: str) -> VectorAssembler: ...
    def setHandleInvalid(self, value: str) -> VectorAssembler: ...

class _VectorIndexerParams(HasInputCol, HasOutputCol, HasHandleInvalid):
    maxCategories: Param[int]
    handleInvalid: Param[str]
    def __init__(self, *args: Any) -> None: ...
    def getMaxCategories(self) -> int: ...

class VectorIndexer(JavaEstimator['VectorIndexerModel'], _VectorIndexerParams, HasHandleInvalid, JavaMLReadable['VectorIndexer'], JavaMLWritable):
    def __init__(self, *, maxCategories: int = 20, inputCol: str | None = None, outputCol: str | None = None, handleInvalid: str = 'error') -> None: ...
    def setParams(self, *, maxCategories: int = 20, inputCol: str | None = None, outputCol: str | None = None, handleInvalid: str = 'error') -> VectorIndexer: ...
    def setMaxCategories(self, value: int) -> VectorIndexer: ...
    def setInputCol(self, value: str) -> VectorIndexer: ...
    def setOutputCol(self, value: str) -> VectorIndexer: ...
    def setHandleInvalid(self, value: str) -> VectorIndexer: ...

class VectorIndexerModel(JavaModel, _VectorIndexerParams, JavaMLReadable['VectorIndexerModel'], JavaMLWritable):
    def setInputCol(self, value: str) -> VectorIndexerModel: ...
    def setOutputCol(self, value: str) -> VectorIndexerModel: ...
    @property
    def numFeatures(self) -> int: ...
    @property
    def categoryMaps(self) -> dict[int, tuple[float, int]]: ...

class VectorSlicer(JavaTransformer, HasInputCol, HasOutputCol, JavaMLReadable['VectorSlicer'], JavaMLWritable):
    indices: Param[list[int]]
    names: Param[list[str]]
    def __init__(self, *, inputCol: str | None = None, outputCol: str | None = None, indices: list[int] | None = None, names: list[str] | None = None) -> None: ...
    def setParams(self, *, inputCol: str | None = None, outputCol: str | None = None, indices: list[int] | None = None, names: list[str] | None = None) -> VectorSlicer: ...
    def setIndices(self, value: list[int]) -> VectorSlicer: ...
    def getIndices(self) -> list[int]: ...
    def setNames(self, value: list[str]) -> VectorSlicer: ...
    def getNames(self) -> list[str]: ...
    def setInputCol(self, value: str) -> VectorSlicer: ...
    def setOutputCol(self, value: str) -> VectorSlicer: ...

class _Word2VecParams(HasStepSize, HasMaxIter, HasSeed, HasInputCol, HasOutputCol):
    vectorSize: Param[int]
    numPartitions: Param[int]
    minCount: Param[int]
    windowSize: Param[int]
    maxSentenceLength: Param[int]
    def __init__(self, *args: Any) -> None: ...
    def getVectorSize(self) -> int: ...
    def getNumPartitions(self) -> int: ...
    def getMinCount(self) -> int: ...
    def getWindowSize(self) -> int: ...
    def getMaxSentenceLength(self) -> int: ...

class Word2Vec(JavaEstimator['Word2VecModel'], _Word2VecParams, JavaMLReadable['Word2Vec'], JavaMLWritable):
    def __init__(self, *, vectorSize: int = 100, minCount: int = 5, numPartitions: int = 1, stepSize: float = 0.025, maxIter: int = 1, seed: int | None = None, inputCol: str | None = None, outputCol: str | None = None, windowSize: int = 5, maxSentenceLength: int = 1000) -> None: ...
    def setParams(self, *, vectorSize: int = 100, minCount: int = 5, numPartitions: int = 1, stepSize: float = 0.025, maxIter: int = 1, seed: int | None = None, inputCol: str | None = None, outputCol: str | None = None, windowSize: int = 5, maxSentenceLength: int = 1000) -> Word2Vec: ...
    def setVectorSize(self, value: int) -> Word2Vec: ...
    def setNumPartitions(self, value: int) -> Word2Vec: ...
    def setMinCount(self, value: int) -> Word2Vec: ...
    def setWindowSize(self, value: int) -> Word2Vec: ...
    def setMaxSentenceLength(self, value: int) -> Word2Vec: ...
    def setMaxIter(self, value: int) -> Word2Vec: ...
    def setInputCol(self, value: str) -> Word2Vec: ...
    def setOutputCol(self, value: str) -> Word2Vec: ...
    def setSeed(self, value: int) -> Word2Vec: ...
    def setStepSize(self, value: float) -> Word2Vec: ...

class Word2VecModel(JavaModel, _Word2VecParams, JavaMLReadable['Word2VecModel'], JavaMLWritable):
    def getVectors(self) -> DataFrame: ...
    def setInputCol(self, value: str) -> Word2VecModel: ...
    def setOutputCol(self, value: str) -> Word2VecModel: ...
    def findSynonyms(self, word: str | Vector, num: int) -> DataFrame: ...
    def findSynonymsArray(self, word: Vector | str, num: int) -> list[tuple[str, float]]: ...

class _PCAParams(HasInputCol, HasOutputCol):
    k: Param[int]
    def getK(self) -> int: ...

class PCA(JavaEstimator['PCAModel'], _PCAParams, JavaMLReadable['PCA'], JavaMLWritable):
    def __init__(self, *, k: int | None = None, inputCol: str | None = None, outputCol: str | None = None) -> None: ...
    def setParams(self, *, k: int | None = None, inputCol: str | None = None, outputCol: str | None = None) -> PCA: ...
    def setK(self, value: int) -> PCA: ...
    def setInputCol(self, value: str) -> PCA: ...
    def setOutputCol(self, value: str) -> PCA: ...

class PCAModel(JavaModel, _PCAParams, JavaMLReadable['PCAModel'], JavaMLWritable):
    def setInputCol(self, value: str) -> PCAModel: ...
    def setOutputCol(self, value: str) -> PCAModel: ...
    @property
    def pc(self) -> DenseMatrix: ...
    @property
    def explainedVariance(self) -> DenseVector: ...

class _RFormulaParams(HasFeaturesCol, HasLabelCol, HasHandleInvalid):
    formula: Param[str]
    forceIndexLabel: Param[bool]
    stringIndexerOrderType: Param[str]
    handleInvalid: Param[str]
    def __init__(self, *args: Any) -> None: ...
    def getFormula(self) -> str: ...
    def getForceIndexLabel(self) -> bool: ...
    def getStringIndexerOrderType(self) -> str: ...

class RFormula(JavaEstimator['RFormulaModel'], _RFormulaParams, JavaMLReadable['RFormula'], JavaMLWritable):
    def __init__(self, *, formula: str | None = None, featuresCol: str = 'features', labelCol: str = 'label', forceIndexLabel: bool = False, stringIndexerOrderType: str = 'frequencyDesc', handleInvalid: str = 'error') -> None: ...
    def setParams(self, *, formula: str | None = None, featuresCol: str = 'features', labelCol: str = 'label', forceIndexLabel: bool = False, stringIndexerOrderType: str = 'frequencyDesc', handleInvalid: str = 'error') -> RFormula: ...
    def setFormula(self, value: str) -> RFormula: ...
    def setForceIndexLabel(self, value: bool) -> RFormula: ...
    def setStringIndexerOrderType(self, value: str) -> RFormula: ...
    def setFeaturesCol(self, value: str) -> RFormula: ...
    def setLabelCol(self, value: str) -> RFormula: ...
    def setHandleInvalid(self, value: str) -> RFormula: ...

class RFormulaModel(JavaModel, _RFormulaParams, JavaMLReadable['RFormulaModel'], JavaMLWritable): ...

class _SelectorParams(HasFeaturesCol, HasOutputCol, HasLabelCol):
    selectorType: Param[str]
    numTopFeatures: Param[int]
    percentile: Param[float]
    fpr: Param[float]
    fdr: Param[float]
    fwe: Param[float]
    def __init__(self, *args: Any) -> None: ...
    def getSelectorType(self) -> str: ...
    def getNumTopFeatures(self) -> int: ...
    def getPercentile(self) -> float: ...
    def getFpr(self) -> float: ...
    def getFdr(self) -> float: ...
    def getFwe(self) -> float: ...

class _Selector(JavaEstimator[JM], _SelectorParams, JavaMLReadable, JavaMLWritable, Generic[JM], metaclass=abc.ABCMeta):
    def setSelectorType(self, value: str) -> P: ...
    def setNumTopFeatures(self, value: int) -> P: ...
    def setPercentile(self, value: float) -> P: ...
    def setFpr(self, value: float) -> P: ...
    def setFdr(self, value: float) -> P: ...
    def setFwe(self, value: float) -> P: ...
    def setFeaturesCol(self, value: str) -> P: ...
    def setOutputCol(self, value: str) -> P: ...
    def setLabelCol(self, value: str) -> P: ...

class _SelectorModel(JavaModel, _SelectorParams):
    def setFeaturesCol(self, value: str) -> P: ...
    def setOutputCol(self, value: str) -> P: ...
    @property
    def selectedFeatures(self) -> list[int]: ...

class ChiSqSelector(_Selector['ChiSqSelectorModel'], JavaMLReadable['ChiSqSelector'], JavaMLWritable):
    def __init__(self, *, numTopFeatures: int = 50, featuresCol: str = 'features', outputCol: str | None = None, labelCol: str = 'label', selectorType: str = 'numTopFeatures', percentile: float = 0.1, fpr: float = 0.05, fdr: float = 0.05, fwe: float = 0.05) -> None: ...
    def setParams(self, *, numTopFeatures: int = 50, featuresCol: str = 'features', outputCol: str | None = None, labelCol: str = 'label', selectorType: str = 'numTopFeatures', percentile: float = 0.1, fpr: float = 0.05, fdr: float = 0.05, fwe: float = 0.05) -> ChiSqSelector: ...

class ChiSqSelectorModel(_SelectorModel, JavaMLReadable['ChiSqSelectorModel'], JavaMLWritable): ...

class VectorSizeHint(JavaTransformer, HasInputCol, HasHandleInvalid, JavaMLReadable['VectorSizeHint'], JavaMLWritable):
    size: Param[int]
    handleInvalid: Param[str]
    def __init__(self, *, inputCol: str | None = None, size: int | None = None, handleInvalid: str = 'error') -> None: ...
    def setParams(self, *, inputCol: str | None = None, size: str | None = None, handleInvalid: str = 'error') -> VectorSizeHint: ...
    def getSize(self) -> int: ...
    def setSize(self, value: int) -> VectorSizeHint: ...
    def setInputCol(self, value: str) -> VectorSizeHint: ...
    def setHandleInvalid(self, value: str) -> VectorSizeHint: ...

class _VarianceThresholdSelectorParams(HasFeaturesCol, HasOutputCol):
    varianceThreshold: Param[float]
    def getVarianceThreshold(self) -> float: ...

class VarianceThresholdSelector(JavaEstimator['VarianceThresholdSelectorModel'], _VarianceThresholdSelectorParams, JavaMLReadable['VarianceThresholdSelector'], JavaMLWritable):
    def __init__(self, *, featuresCol: str = 'features', outputCol: str | None = None, varianceThreshold: float = 0.0) -> None: ...
    def setParams(self, *, featuresCol: str = 'features', outputCol: str | None = None, varianceThreshold: float = 0.0) -> VarianceThresholdSelector: ...
    def setVarianceThreshold(self, value: float) -> VarianceThresholdSelector: ...
    def setFeaturesCol(self, value: str) -> VarianceThresholdSelector: ...
    def setOutputCol(self, value: str) -> VarianceThresholdSelector: ...

class VarianceThresholdSelectorModel(JavaModel, _VarianceThresholdSelectorParams, JavaMLReadable['VarianceThresholdSelectorModel'], JavaMLWritable):
    def setFeaturesCol(self, value: str) -> VarianceThresholdSelectorModel: ...
    def setOutputCol(self, value: str) -> VarianceThresholdSelectorModel: ...
    @property
    def selectedFeatures(self) -> list[int]: ...

class _UnivariateFeatureSelectorParams(HasFeaturesCol, HasOutputCol, HasLabelCol):
    featureType: Param[str]
    labelType: Param[str]
    selectionMode: Param[str]
    selectionThreshold: Param[float]
    def __init__(self, *args: Any) -> None: ...
    def getFeatureType(self) -> str: ...
    def getLabelType(self) -> str: ...
    def getSelectionMode(self) -> str: ...
    def getSelectionThreshold(self) -> float: ...

class UnivariateFeatureSelector(JavaEstimator['UnivariateFeatureSelectorModel'], _UnivariateFeatureSelectorParams, JavaMLReadable['UnivariateFeatureSelector'], JavaMLWritable):
    def __init__(self, *, featuresCol: str = 'features', outputCol: str | None = None, labelCol: str = 'label', selectionMode: str = 'numTopFeatures') -> None: ...
    def setParams(self, *, featuresCol: str = 'features', outputCol: str | None = None, labelCol: str = 'label', selectionMode: str = 'numTopFeatures') -> UnivariateFeatureSelector: ...
    def setFeatureType(self, value: str) -> UnivariateFeatureSelector: ...
    def setLabelType(self, value: str) -> UnivariateFeatureSelector: ...
    def setSelectionMode(self, value: str) -> UnivariateFeatureSelector: ...
    def setSelectionThreshold(self, value: float) -> UnivariateFeatureSelector: ...
    def setFeaturesCol(self, value: str) -> UnivariateFeatureSelector: ...
    def setOutputCol(self, value: str) -> UnivariateFeatureSelector: ...
    def setLabelCol(self, value: str) -> UnivariateFeatureSelector: ...

class UnivariateFeatureSelectorModel(JavaModel, _UnivariateFeatureSelectorParams, JavaMLReadable['UnivariateFeatureSelectorModel'], JavaMLWritable):
    def setFeaturesCol(self, value: str) -> UnivariateFeatureSelectorModel: ...
    def setOutputCol(self, value: str) -> UnivariateFeatureSelectorModel: ...
    @property
    def selectedFeatures(self) -> list[int]: ...

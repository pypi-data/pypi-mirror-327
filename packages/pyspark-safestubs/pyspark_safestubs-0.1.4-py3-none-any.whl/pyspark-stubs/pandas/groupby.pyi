import pandas as pd
from _typeshed import Incomplete
from abc import ABCMeta
from pyspark.pandas._typing import Axis as Axis, FrameLike as FrameLike, Label as Label, Name as Name
from pyspark.pandas.config import get_option as get_option
from pyspark.pandas.exceptions import DataError as DataError
from pyspark.pandas.frame import DataFrame as DataFrame
from pyspark.pandas.internal import HIDDEN_COLUMNS as HIDDEN_COLUMNS, InternalField as InternalField, InternalFrame as InternalFrame, NATURAL_ORDER_COLUMN_NAME as NATURAL_ORDER_COLUMN_NAME, SPARK_DEFAULT_SERIES_NAME as SPARK_DEFAULT_SERIES_NAME, SPARK_INDEX_NAME_FORMAT as SPARK_INDEX_NAME_FORMAT, SPARK_INDEX_NAME_PATTERN as SPARK_INDEX_NAME_PATTERN
from pyspark.pandas.missing.groupby import MissingPandasLikeDataFrameGroupBy as MissingPandasLikeDataFrameGroupBy, MissingPandasLikeSeriesGroupBy as MissingPandasLikeSeriesGroupBy
from pyspark.pandas.series import Series as Series, first_series as first_series
from pyspark.pandas.spark.utils import as_nullable_spark_type as as_nullable_spark_type, force_decimal_precision_scale as force_decimal_precision_scale
from pyspark.pandas.typedef import DataFrameType as DataFrameType, ScalarType as ScalarType, SeriesType as SeriesType, infer_return_type as infer_return_type
from pyspark.pandas.utils import align_diff_frames as align_diff_frames, is_name_like_tuple as is_name_like_tuple, is_name_like_value as is_name_like_value, log_advice as log_advice, name_like_string as name_like_string, same_anchor as same_anchor, scol_for as scol_for, verify_temp_column_name as verify_temp_column_name
from pyspark.pandas.window import ExpandingGroupby as ExpandingGroupby, ExponentialMovingGroupby as ExponentialMovingGroupby, RollingGroupby as RollingGroupby
from pyspark.sql import Column as Column, Window as Window
from pyspark.sql.types import BooleanType as BooleanType, DataType as DataType, DoubleType as DoubleType, NumericType as NumericType, StringType as StringType, StructField as StructField, StructType as StructType
from typing import Any, Callable, Generic, NamedTuple

class NamedAgg(NamedTuple):
    column: Incomplete
    aggfunc: Incomplete

class GroupBy(Generic[FrameLike], metaclass=ABCMeta):
    def __init__(self, psdf: DataFrame, groupkeys: list[Series], as_index: bool, dropna: bool, column_labels_to_exclude: set[Label], agg_columns_selected: bool, agg_columns: list[Series]) -> None: ...
    def aggregate(self, func_or_funcs: str | list[str] | dict[Name, str | list[str]] | None = None, *args: Any, **kwargs: Any) -> DataFrame: ...
    agg = aggregate
    def count(self) -> FrameLike: ...
    def first(self, numeric_only: bool | None = False, min_count: int = -1) -> FrameLike: ...
    def last(self, numeric_only: bool | None = False, min_count: int = -1) -> FrameLike: ...
    def max(self, numeric_only: bool | None = False, min_count: int = -1) -> FrameLike: ...
    def mean(self, numeric_only: bool | None = True) -> FrameLike: ...
    def quantile(self, q: float = 0.5, accuracy: int = 10000) -> FrameLike: ...
    def min(self, numeric_only: bool | None = False, min_count: int = -1) -> FrameLike: ...
    def std(self, ddof: int = 1) -> FrameLike: ...
    def sum(self, numeric_only: bool | None = True, min_count: int = 0) -> FrameLike: ...
    def var(self, ddof: int = 1) -> FrameLike: ...
    def skew(self) -> FrameLike: ...
    def mad(self) -> FrameLike: ...
    def sem(self, ddof: int = 1) -> FrameLike: ...
    def nth(self, n: int) -> FrameLike: ...
    def prod(self, numeric_only: bool | None = True, min_count: int = 0) -> FrameLike: ...
    def all(self, skipna: bool = True) -> FrameLike: ...
    def any(self) -> FrameLike: ...
    def size(self) -> Series: ...
    def diff(self, periods: int = 1) -> FrameLike: ...
    def cumcount(self, ascending: bool = True) -> Series: ...
    def cummax(self) -> FrameLike: ...
    def cummin(self) -> FrameLike: ...
    def cumprod(self) -> FrameLike: ...
    def cumsum(self) -> FrameLike: ...
    def apply(self, func: Callable, *args: Any, **kwargs: Any) -> DataFrame | Series: ...
    def filter(self, func: Callable[[FrameLike], FrameLike]) -> FrameLike: ...
    def rank(self, method: str = 'average', ascending: bool = True) -> FrameLike: ...
    def idxmax(self, skipna: bool = True) -> FrameLike: ...
    def idxmin(self, skipna: bool = True) -> FrameLike: ...
    def fillna(self, value: Any | None = None, method: str | None = None, axis: Axis | None = None, inplace: bool = False, limit: int | None = None) -> FrameLike: ...
    def bfill(self, limit: int | None = None) -> FrameLike: ...
    def backfill(self, limit: int | None = None) -> FrameLike: ...
    def ffill(self, limit: int | None = None) -> FrameLike: ...
    def pad(self, limit: int | None = None) -> FrameLike: ...
    def head(self, n: int = 5) -> FrameLike: ...
    def tail(self, n: int = 5) -> FrameLike: ...
    def shift(self, periods: int = 1, fill_value: Any | None = None) -> FrameLike: ...
    def transform(self, func: Callable[..., pd.Series], *args: Any, **kwargs: Any) -> FrameLike: ...
    def nunique(self, dropna: bool = True) -> FrameLike: ...
    def rolling(self, window: int, min_periods: int | None = None) -> RollingGroupby[FrameLike]: ...
    def expanding(self, min_periods: int = 1) -> ExpandingGroupby[FrameLike]: ...
    def ewm(self, com: float | None = None, span: float | None = None, halflife: float | None = None, alpha: float | None = None, min_periods: int | None = None, ignore_na: bool = False) -> ExponentialMovingGroupby[FrameLike]: ...
    def get_group(self, name: Name | list[Name]) -> FrameLike: ...
    def median(self, numeric_only: bool | None = True, accuracy: int = 10000) -> FrameLike: ...

class DataFrameGroupBy(GroupBy[DataFrame]):
    def __init__(self, psdf: DataFrame, by: list[Series], as_index: bool, dropna: bool, column_labels_to_exclude: set[Label], agg_columns: list[Label] = None) -> None: ...
    def __getattr__(self, item: str) -> Any: ...
    def __getitem__(self, item: Any) -> GroupBy: ...
    def describe(self) -> DataFrame: ...

class SeriesGroupBy(GroupBy[Series]):
    def __init__(self, psser: Series, by: list[Series], as_index: bool = True, dropna: bool = True) -> None: ...
    def __getattr__(self, item: str) -> Any: ...
    def agg(self, *args: Any, **kwargs: Any) -> None: ...
    def aggregate(self, *args: Any, **kwargs: Any) -> None: ...
    def size(self) -> Series: ...
    def nsmallest(self, n: int = 5) -> Series: ...
    def nlargest(self, n: int = 5) -> Series: ...
    def value_counts(self, sort: bool | None = None, ascending: bool | None = None, dropna: bool = True) -> Series: ...
    def unique(self) -> Series: ...

def is_multi_agg_with_relabel(**kwargs: Any) -> bool: ...
def normalize_keyword_aggregation(kwargs: dict[str, tuple[Name, str]]) -> tuple[dict[Name, list[str]], list[str], list[tuple]]: ...

from typing import Any, Callable, Literal, TypeVar, Union, overload

from _typeshed import Incomplete
from pyspark import SparkContext as SparkContext
from pyspark.errors import PySparkTypeError as PySparkTypeError
from pyspark.errors import PySparkValueError as PySparkValueError
from pyspark.sql._typing import ColumnOrName, DataTypeOrString, UserDefinedFunctionLike
from pyspark.sql.column import Column
from pyspark.sql.dataframe import DataFrame as DataFrame
from pyspark.sql.pandas.functions import PandasUDFType as PandasUDFType
from pyspark.sql.pandas.functions import pandas_udf as pandas_udf
from pyspark.sql.types import ArrayType as ArrayType
from pyspark.sql.types import DataType as DataType
from pyspark.sql.types import StringType as StringType
from pyspark.sql.types import StructType as StructType
from pyspark.sql.udf import UserDefinedFunction as UserDefinedFunction
from pyspark.sql.udtf import UserDefinedTableFunction as UserDefinedTableFunction
from pyspark.sql.utils import get_active_spark_context as get_active_spark_context
from pyspark.sql.utils import has_numpy as has_numpy
from pyspark.sql.utils import to_str as to_str
from pyspark.sql.utils import try_remote_functions as try_remote_functions
from typing_extensions import LiteralString

T = TypeVar("T", bound=LiteralString, covariant=True)
In = TypeVar("In", bound=LiteralString, covariant=True)
In2 = TypeVar("In2", bound=LiteralString, covariant=True)
ConcatValue = TypeVar("ConcatValue", bound=Union[str,int])
Out = TypeVar("Out", bound=LiteralString, covariant=True)

def lit(col: Any) -> Column[Literal['lit'], Literal['expr'] ]: ...
def col(col: T) -> Column[T, T]: ...
column = col

def asc(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def desc(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def sqrt(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def try_add(left: Column[In, Out], right: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def try_avg(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def try_divide(left: Column[In, Out], right: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def try_multiply(left: Column[In, Out], right: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def try_subtract(left: Column[In, Out], right: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def try_sum(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def abs(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def mode(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def max(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def min(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def max_by(col: Column[In, Out], ord: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def min_by(col: Column[In, Out], ord: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def count(col: Union[Column[In, Out], Literal['*']]) -> Column[Literal['lit'], Literal['expr']]: ...
def sum(col: ColumnOrName[In, Out]) -> Column[In, Literal['expr']]: ...
def avg(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def mean(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def median(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def sumDistinct(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def sum_distinct(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def product(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def acos(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def acosh(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def asin(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def asinh(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def atan(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def atanh(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def cbrt(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def ceil(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def ceiling(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def cos(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def cosh(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def cot(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def csc(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def e() -> Column[In, Literal['expr']]: ...
def exp(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def expm1(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def floor(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def log(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def log10(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def log1p(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def negative(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
negate = negative

def pi() -> Column[In, Literal['expr']]: ...
def positive(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def rint(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def sec(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def signum(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def sign(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def sin(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def sinh(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def tan(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def tanh(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def toDegrees(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def toRadians(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def bitwiseNOT(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def bitwise_not(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def bit_count(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def bit_get(col: Column[In, Out], pos: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def getbit(col: Column[In, Out], pos: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def asc_nulls_first(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def asc_nulls_last(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def desc_nulls_first(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def desc_nulls_last(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def stddev(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def std(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def stddev_samp(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def stddev_pop(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def variance(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def var_samp(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def var_pop(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def regr_avgx(y: Column[In, Out], x: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def regr_avgy(y: Column[In, Out], x: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def regr_count(y: Column[In, Out], x: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def regr_intercept(y: Column[In, Out], x: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def regr_r2(y: Column[In, Out], x: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def regr_slope(y: Column[In, Out], x: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def regr_sxx(y: Column[In, Out], x: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def regr_sxy(y: Column[In, Out], x: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def regr_syy(y: Column[In, Out], x: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def every(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def bool_and(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def some(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def bool_or(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def bit_and(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def bit_or(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def bit_xor(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def skewness(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def kurtosis(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def collect_list(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def array_agg(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def collect_set(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def degrees(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def radians(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def atan2(col1: Column[In, Out] | float, col2: Column[In, Out] | float) -> Column[In, Literal['expr']]: ...
def hypot(col1: Column[In, Out] | float, col2: Column[In, Out] | float) -> Column[In, Literal['expr']]: ...
def pow(col1: Column[In, Out] | float, col2: Column[In, Out] | float) -> Column[In, Literal['expr']]: ...
power = pow

def pmod(dividend: Column[In, Out] | float, divisor: Column[In, Out] | float) -> Column[In, Literal['expr']]: ...
def width_bucket(v: Column[In, Out], min: Column[In, Out], max: Column[In, Out], numBucket: Column[In, Out] | int) -> Column[In, Literal['expr']]: ...
def row_number() -> Column[In, Literal['expr']]: ...
def dense_rank() -> Column[In, Literal['expr']]: ...
def rank() -> Column[Literal['lit'], Literal['expr']]: ...
def cume_dist() -> Column[In, Literal['expr']]: ...
def percent_rank() -> Column[In, Literal['expr']]: ...
def approxCountDistinct(col: Column[In, Out], rsd: float | None = None) -> Column[In, Literal['expr']]: ...
def approx_count_distinct(col: Column[In, Out], rsd: float | None = None) -> Column[In, Literal['expr']]: ...
def broadcast(df: DataFrame) -> DataFrame: ...
def coalesce(*cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def corr(col1: Column[In, Out], col2: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def covar_pop(col1: Column[In, Out], col2: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def covar_samp(col1: Column[In, Out], col2: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def countDistinct(col: Column[In, Out], *cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def count_distinct(col: Column[In, Out], *cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def first(col: Column[In, Out], ignorenulls: bool = False) -> Column[In, Literal['expr']]: ...
def grouping(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def grouping_id(*cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def count_min_sketch(col: Column[In, Out], eps: Column[In, Out], confidence: Column[In, Out], seed: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def input_file_name() -> Column[In, Literal['expr']]: ...
def isnan(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def isnull(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def last(col: Column[In, Out], ignorenulls: bool = False) -> Column[In, Literal['expr']]: ...
def monotonically_increasing_id() -> Column[In, Literal['expr']]: ...
def nanvl(col1: Column[In, Out], col2: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def percentile(col: Column[In, Out], percentage: Column | float | list[float] | tuple[float], frequency: Column | int = 1) -> Column[In, Literal['expr']]: ...
def percentile_approx(col: Column[In, Out], percentage: Column | float | list[float] | tuple[float], accuracy: Column | float = 10000) -> Column[In, Literal['expr']]: ...
def approx_percentile(col: Column[In, Out], percentage: Column | float | list[float] | tuple[float], accuracy: Column | float = 10000) -> Column[In, Literal['expr']]: ...
def rand(seed: int | None = None) -> Column[In, Literal['expr']]: ...
def randn(seed: int | None = None) -> Column[In, Literal['expr']]: ...
def round(col: Column[In, Out], scale: int = 0) -> Column[In, Literal['expr']]: ...
def bround(col: Column[In, Out], scale: int = 0) -> Column[In, Literal['expr']]: ...
def shiftLeft(col: Column[In, Out], numBits: int) -> Column[In, Literal['expr']]: ...
def shiftleft(col: Column[In, Out], numBits: int) -> Column[In, Literal['expr']]: ...
def shiftRight(col: Column[In, Out], numBits: int) -> Column[In, Literal['expr']]: ...
def shiftright(col: Column[In, Out], numBits: int) -> Column[In, Literal['expr']]: ...
def shiftRightUnsigned(col: Column[In, Out], numBits: int) -> Column[In, Literal['expr']]: ...
def shiftrightunsigned(col: Column[In, Out], numBits: int) -> Column[In, Literal['expr']]: ...
def spark_partition_id() -> Column[In, Literal['expr']]: ...
def expr(str: str) -> Column[In, Literal['expr']]: ...
@overload
def struct(*cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
@overload
def struct(__cols: list['Column[In, Out]_'] | tuple['Column[In, Out]_', ...], /) -> Column[In, Literal['expr']]: ...
def named_struct(*cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def greatest(*cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def least(*cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
@overload
def when(condition: Column[In, Any], value: Column[In2, Any]) -> Column[Union[In, In2], Literal['expr']]: ...
@overload
def when(condition: Column[In, Any], value: int) -> Column[In, Literal['expr']]: ...
@overload
def when(condition: Column[In, Any], value: float) -> Column[In, Literal['expr']]: ...
@overload
def when(condition: Column[In, Any], value: str) -> Column[In, Literal['expr']]: ...
@overload
def log(arg1: Column[In, Out]) -> Column[In, Literal['expr']]: ...
@overload
def log(arg1: float, arg2: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def ln(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def log2(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def conv(col: Column[In, Out], fromBase: int, toBase: int) -> Column[In, Literal['expr']]: ...
def factorial(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def lag(col: Column[In, Out], offset: int = 1, default: Any | None = None) -> Column[In, Literal['expr']]: ...
def lead(col: Column[In, Out], offset: int = 1, default: Any | None = None) -> Column[In, Literal['expr']]: ...
def nth_value(col: Column[In, Out], offset: int, ignoreNulls: bool | None = False) -> Column[In, Literal['expr']]: ...
def any_value(col: Column[In, Out], ignoreNulls: bool | Column | None = None) -> Column[In, Literal['expr']]: ...
def first_value(col: Column[In, Out], ignoreNulls: bool | Column | None = None) -> Column[In, Literal['expr']]: ...
def last_value(col: Column[In, Out], ignoreNulls: bool | Column | None = None) -> Column[In, Literal['expr']]: ...
def count_if(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def histogram_numeric(col: Column[In, Out], nBins: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def ntile(n: int) -> Column[Literal['lit'], Literal['expr']]: ...
def curdate() -> Column[Literal['lit'], Literal['expr']]: ...
def current_date() -> Column[Literal['lit'], Literal['expr']]: ...
def current_timezone() -> Column[Literal['lit'], Literal['expr']]: ...
def current_timestamp() -> Column[Literal['lit'], Literal['expr']]: ...
def now() -> Column[Literal['lit'], Literal['expr']]: ...
def localtimestamp() -> Column[Literal['lit'], Literal['expr']]: ...
def date_format(date: Column[In, Out], format: str) -> Column[In, Literal['expr']]: ...
def year(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def quarter(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def month(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def dayofweek(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def dayofmonth(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def day(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def dayofyear(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def hour(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def minute(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def second(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def weekofyear(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def weekday(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def extract(field: Column[In, Out], source: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def date_part(field: Column[In, Out], source: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def datepart(field: Column[In, Out], source: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def make_date(year: Column[In, Out], month: Column[In, Out], day: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def date_add(start: Column[In, Out], days: Column[In, Out] | int) -> Column[In, Literal['expr']]: ...
def dateadd(start: Column[In, Out], days: Column[In, Out] | int) -> Column[In, Literal['expr']]: ...
def date_sub(start: Column[In, Out], days: Column[In, Out] | int) -> Column[In, Literal['expr']]: ...
def datediff(end: Column[In, Out], start: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def date_diff(end: Column[In, Out], start: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def date_from_unix_date(days: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def add_months(start: Column[In, Out], months: Column[In, Out] | int) -> Column[In, Literal['expr']]: ...
def months_between(date1: Column[In, Out], date2: Column[In, Out], roundOff: bool = True) -> Column[In, Literal['expr']]: ...
def to_date(col: Column[In, Out], format: str | None = None) -> Column[In, Literal['expr']]: ...
def unix_date(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def unix_micros(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def unix_millis(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def unix_seconds(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
@overload
def to_timestamp(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
@overload
def to_timestamp(col: Column[In, Out], format: str) -> Column[In, Literal['expr']]: ...
def try_to_timestamp(col: Column[In, Out], format: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def xpath(xml: Column[In, Out], path: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def xpath_boolean(xml: Column[In, Out], path: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def xpath_double(xml: Column[In, Out], path: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def xpath_number(xml: Column[In, Out], path: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def xpath_float(xml: Column[In, Out], path: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def xpath_int(xml: Column[In, Out], path: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def xpath_long(xml: Column[In, Out], path: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def xpath_short(xml: Column[In, Out], path: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def xpath_string(xml: Column[In, Out], path: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def trunc(date: Column[In, Out], format: str) -> Column[In, Literal['expr']]: ...
def date_trunc(format: str, timestamp: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def next_day(date: Column[In, Out], dayOfWeek: str) -> Column[In, Literal['expr']]: ...
def last_day(date: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def from_unixtime(timestamp: Column[In, Out], format: str = 'yyyy-MM-dd HH:mm:ss') -> Column[In, Literal['expr']]: ...
@overload
def unix_timestamp(timestamp: Column[In, Out], format: str = ...) -> Column[In, Literal['expr']]: ...
@overload
def unix_timestamp() -> Column[In, Literal['expr']]: ...
def from_utc_timestamp(timestamp: Column[In, Out], tz: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def to_utc_timestamp(timestamp: Column[In, Out], tz: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def timestamp_seconds(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def timestamp_millis(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def timestamp_micros(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def window(timeColumn: Column[In, Out], windowDuration: str, slideDuration: str | None = None, startTime: str | None = None) -> Column[In, Literal['expr']]: ...
def window_time(windowColumn: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def session_window(timeColumn: Column[In, Out], gapDuration: Column | str) -> Column[In, Literal['expr']]: ...
def to_unix_timestamp(timestamp: Column[In, Out], format: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def to_timestamp_ltz(timestamp: Column[In, Out], format: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def to_timestamp_ntz(timestamp: Column[In, Out], format: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def current_catalog() -> Column[In, Literal['expr']]: ...
def current_database() -> Column[In, Literal['expr']]: ...
def current_schema() -> Column[In, Literal['expr']]: ...
def current_user() -> Column[In, Literal['expr']]: ...
def user() -> Column[In, Literal['expr']]: ...
def crc32(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def md5(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def sha1(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def sha2(col: Column[In, Out], numBits: int) -> Column[In, Literal['expr']]: ...
def hash(*cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def xxhash64(*cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def assert_true(col: Column[In, Out], errMsg: Column | str | None = None) -> Column[In, Literal['expr']]: ...
def raise_error(errMsg: Column | str) -> Column[In, Literal['expr']]: ...
def upper(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def lower(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def ascii(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def base64(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def unbase64(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def ltrim(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def rtrim(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def trim(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def concat_ws(sep: str, *cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def decode(col: Column[In, Out], charset: str) -> Column[In, Literal['expr']]: ...
def encode(col: Column[In, Out], charset: str) -> Column[In, Literal['expr']]: ...
def format_number(col: Column[In, Out], d: int) -> Column[In, Literal['expr']]: ...
def format_string(format: str, *cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def instr(str: Column[In, Out], substr: str) -> Column[In, Literal['expr']]: ...
def overlay(src: Column[In, Out], replace: Column[In, Out], pos: Column[In, Out] | int, len: Column[In, Out] | int = -1) -> Column[In, Literal['expr']]: ...
def sentences(string: Column[In, Out], language: Column[In, Out] | None = None, country: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def substring(str: Column[In, Out], pos: int, len: int) -> Column[In, Literal['expr']]: ...
def substring_index(str: Column[In, Out], delim: str, count: int) -> Column[In, Literal['expr']]: ...
def levenshtein(left: Column[In, Out], right: Column[In, Out], threshold: int | None = None) -> Column[In, Literal['expr']]: ...
def locate(substr: str, str: Column[In, Out], pos: int = 1) -> Column[In, Literal['expr']]: ...
def lpad(col: Column[In, Out], len: int, pad: str) -> Column[In, Literal['expr']]: ...
def rpad(col: Column[In, Out], len: int, pad: str) -> Column[In, Literal['expr']]: ...
def repeat(col: Column[In, Out], n: int) -> Column[In, Literal['expr']]: ...
def split(str: Column[In, Out], pattern: str, limit: int = -1) -> Column[In, Literal['expr']]: ...
def rlike(str: Column[In, Out], regexp: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def regexp(str: Column[In, Out], regexp: Column[In, Out]) -> Column[In, Literal['expr']]: ...
@overload
def regexp_like(str: Column[In, Out], regexp: str) -> Column[In, Literal['expr']]: ...
@overload
def regexp_like(str: Column[In, Any], regexp: Column[In2, Any]) -> Column[Union[In, In2], Literal['expr']]: ...
def regexp_count(str: Column[In, Out], regexp: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def regexp_extract(str: Column[In, Out], pattern: str, idx: int) -> Column[In, Literal['expr']]: ...
def regexp_extract_all(str: Column[In, Out], regexp: Column[In, Out], idx: int | Column | None = None) -> Column[In, Literal['expr']]: ...
def regexp_replace(string: Column[In, Out], pattern: str | Column, replacement: str | Column) -> Column[In, Literal['expr']]: ...
def regexp_substr(str: Column[In, Out], regexp: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def regexp_instr(str: Column[In, Out], regexp: Column[In, Out], idx: int | Column | None = None) -> Column[In, Literal['expr']]: ...
def initcap(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def soundex(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def bin(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def hex(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def unhex(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def length(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def octet_length(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def bit_length(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def translate(srcCol: Column[In, Out], matching: str, replace: str) -> Column[In, Literal['expr']]: ...
def to_binary(col: Column[In, Out], format: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def to_char(col: Column[In, Out], format: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def to_varchar(col: Column[In, Out], format: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def to_number(col: Column[In, Out], format: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def replace(src: Column[In, Out], search: Column[In, Out], replace: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def split_part(src: Column[In, Out], delimiter: Column[In, Out], partNum: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def substr(str: Column[In, Out], pos: Column[In, Out], len: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def parse_url(url: Column[In, Out], partToExtract: Column[In, Out], key: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def printf(format: Column[In, Out], *cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def url_decode(str: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def url_encode(str: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def position(substr: Column[In, Out], str: Column[In, Out], start: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def endswith(str: Column[In, Out], suffix: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def startswith(str: Column[In, Out], prefix: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def char(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def btrim(str: Column[In, Out], trim: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def char_length(str: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def character_length(str: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def try_to_binary(col: Column[In, Out], format: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def try_to_number(col: Column[In, Out], format: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def contains(left: Column[In, Out], right: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def elt(*inputs: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def find_in_set(str: Column[In, Out], str_array: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def like(str: Column[In, Out], pattern: Column[In, Out], escapeChar: Column | None = None) -> Column[In, Literal['expr']]: ...
def ilike(str: Column[In, Out], pattern: Column[In, Out], escapeChar: Column | None = None) -> Column[In, Literal['expr']]: ...
def lcase(str: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def ucase(str: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def left(str: Column[In, Out], len: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def right(str: Column[In, Out], len: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def mask(col: Column[In, Out], upperChar: Column[In, Out] | None = None, lowerChar: Column[In, Out] | None = None, digitChar: Column[In, Out] | None = None, otherChar: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
@overload
def create_map(*cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
@overload
def create_map(__cols: list['Column[In, Out]_'] | tuple['Column[In, Out]_', ...], /) -> Column[In, Literal['expr']]: ...
def map_from_arrays(col1: Column[In, Out], col2: Column[In, Out]) -> Column[In, Literal['expr']]: ...
@overload
def array(*cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
@overload
def array(__cols: list['Column[In, Out]_'] | tuple['Column[In, Out]_', ...], /) -> Column[In, Literal['expr']]: ...
def array_contains(col: Column[In, Out], value: Any) -> Column[In, Literal['expr']]: ...
def arrays_overlap(a1: Column[In, Out], a2: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def slice(x: Column[In, Out], start: Column[In, Out] | int, length: Column[In, Out] | int) -> Column[In, Literal['expr']]: ...
def array_join(col: Column[In, Out], delimiter: str, null_replacement: str | None = None) -> Column[In, Literal['expr']]: ...

def concat(*cols: Union[Column[In, Out], ConcatValue]) -> Column[In, Literal['expr']]: ...
def array_position(col: Column[In, Out], value: Any) -> Column[In, Literal['expr']]: ...
def element_at(col: Column[In, Out], extraction: Any) -> Column[In, Literal['expr']]: ...
def try_element_at(col: Column[In, Out], extraction: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def get(col: Column[In, Out], index: Column[In, Out] | int) -> Column[In, Literal['expr']]: ...
def array_prepend(col: Column[In, Out], value: Any) -> Column[In, Literal['expr']]: ...
def array_remove(col: Column[In, Out], element: Any) -> Column[In, Literal['expr']]: ...
def array_distinct(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def array_insert(arr: Column[In, Out], pos: Column[In, Out] | int, value: Any) -> Column[In, Literal['expr']]: ...
def array_intersect(col1: Column[In, Out], col2: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def array_union(col1: Column[In, Out], col2: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def array_except(col1: Column[In, Out], col2: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def array_compact(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def array_append(col: Column[In, Out], value: Any) -> Column[In, Literal['expr']]: ...
def explode(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def posexplode(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def inline(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def explode_outer(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def posexplode_outer(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def inline_outer(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def get_json_object(col: Column[In, Out], path: str) -> Column[In, Literal['expr']]: ...
def json_tuple(col: Column[In, Out], *fields: str) -> Column[In, Literal['expr']]: ...
def from_json(col: Column[In, Out], schema: ArrayType | StructType | Column | str, options: dict[str, str] | None = None) -> Column[In, Literal['expr']]: ...
def to_json(col: Column[In, Out], options: dict[str, str] | None = None) -> Column[In, Literal['expr']]: ...
def schema_of_json(json: Column[In, Out], options: dict[str, str] | None = None) -> Column[In, Literal['expr']]: ...
def json_array_length(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def json_object_keys(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def schema_of_csv(csv: Column[In, Out], options: dict[str, str] | None = None) -> Column[In, Literal['expr']]: ...
def to_csv(col: Column[In, Out], options: dict[str, str] | None = None) -> Column[In, Literal['expr']]: ...
def size(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def array_min(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def array_max(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def array_size(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def cardinality(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def sort_array(col: Column[In, Out], asc: bool = True) -> Column[In, Literal['expr']]: ...
def array_sort(col: Column[In, Out], comparator: Callable[[Column, Column], Column] | None = None) -> Column[In, Literal['expr']]: ...
def shuffle(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def reverse(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def flatten(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def map_contains_key(col: Column[In, Out], value: Any) -> Column[In, Literal['expr']]: ...
def map_keys(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def map_values(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def map_entries(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def map_from_entries(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def array_repeat(col: Column[In, Out], count: Column[In, Out] | int) -> Column[In, Literal['expr']]: ...
def arrays_zip(*cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
@overload
def map_concat(*cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
@overload
def map_concat(__cols: list['Column[In, Out]_'] | tuple['Column[In, Out]_', ...], /) -> Column[In, Literal['expr']]: ...
def sequence(start: Column[In, Out], stop: Column[In, Out], step: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def from_csv(col: Column[In, Out], schema: Column | str, options: dict[str, str] | None = None) -> Column[In, Literal['expr']]: ...
@overload
def transform(col: Column[In, Out], f: Callable[[Column], Column]) -> Column[In, Literal['expr']]: ...
@overload
def transform(col: Column[In, Out], f: Callable[[Column, Column], Column]) -> Column[In, Literal['expr']]: ...
def exists(col: Column[In, Out], f: Callable[[Column], Column]) -> Column[In, Literal['expr']]: ...
def forall(col: Column[In, Out], f: Callable[[Column], Column]) -> Column[In, Literal['expr']]: ...
@overload
def filter(col: Column[In, Out], f: Callable[[Column], Column]) -> Column[In, Literal['expr']]: ...
@overload
def filter(col: Column[In, Out], f: Callable[[Column, Column], Column]) -> Column[In, Literal['expr']]: ...
def aggregate(col: Column[In, Out], initialValue: Column[In, Out], merge: Callable[[Column, Column], Column], finish: Callable[[Column], Column] | None = None) -> Column[In, Literal['expr']]: ...
def reduce(col: Column[In, Out], initialValue: Column[In, Out], merge: Callable[[Column, Column], Column], finish: Callable[[Column], Column] | None = None) -> Column[In, Literal['expr']]: ...
def zip_with(left: Column[In, Out], right: Column[In, Out], f: Callable[[Column, Column], Column]) -> Column[In, Literal['expr']]: ...
def transform_keys(col: Column[In, Out], f: Callable[[Column, Column], Column]) -> Column[In, Literal['expr']]: ...
def transform_values(col: Column[In, Out], f: Callable[[Column, Column], Column]) -> Column[In, Literal['expr']]: ...
def map_filter(col: Column[In, Out], f: Callable[[Column, Column], Column]) -> Column[In, Literal['expr']]: ...
def map_zip_with(col1: Column[In, Out], col2: Column[In, Out], f: Callable[[Column, Column, Column], Column]) -> Column[In, Literal['expr']]: ...
def str_to_map(text: Column[In, Out], pairDelim: Column[In, Out] | None = None, keyValueDelim: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def years(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def months(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def days(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def hours(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def convert_timezone(sourceTz: Column | None, targetTz: Column, sourceTs: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def make_dt_interval(days: Column[In, Out] | None = None, hours: Column[In, Out] | None = None, mins: Column[In, Out] | None = None, secs: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def make_interval(years: Column[In, Out] | None = None, months: Column[In, Out] | None = None, weeks: Column[In, Out] | None = None, days: Column[In, Out] | None = None, hours: Column[In, Out] | None = None, mins: Column[In, Out] | None = None, secs: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def make_timestamp(years: Column[In, Out], months: Column[In, Out], days: Column[In, Out], hours: Column[In, Out], mins: Column[In, Out], secs: Column[In, Out], timezone: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def make_timestamp_ltz(years: Column[In, Out], months: Column[In, Out], days: Column[In, Out], hours: Column[In, Out], mins: Column[In, Out], secs: Column[In, Out], timezone: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def make_timestamp_ntz(years: Column[In, Out], months: Column[In, Out], days: Column[In, Out], hours: Column[In, Out], mins: Column[In, Out], secs: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def make_ym_interval(years: Column[In, Out] | None = None, months: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def bucket(numBuckets: Column | int, col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def call_udf(udfName: str, *cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def call_function(funcName: str, *cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def unwrap_udt(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def hll_sketch_agg(col: Column[In, Out], lgConfigK: int | Column | None = None) -> Column[In, Literal['expr']]: ...
def hll_union_agg(col: Column[In, Out], allowDifferentLgConfigK: bool | Column | None = None) -> Column[In, Literal['expr']]: ...
def hll_sketch_estimate(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def hll_union(col1: Column[In, Out], col2: Column[In, Out], allowDifferentLgConfigK: bool | None = None) -> Column[In, Literal['expr']]: ...
def ifnull(col1: Column[In, Out], col2: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def isnotnull(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def equal_null(col1: Column[In, Out], col2: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def nullif(col1: Column[In, Out], col2: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def nvl(col1: Column[In, Out], col2: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def nvl2(col1: Column[In, Out], col2: Column[In, Out], col3: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def aes_encrypt(input: Column[In, Out], key: Column[In, Out], mode: Column[In, Out] | None = None, padding: Column[In, Out] | None = None, iv: Column[In, Out] | None = None, aad: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def aes_decrypt(input: Column[In, Out], key: Column[In, Out], mode: Column[In, Out] | None = None, padding: Column[In, Out] | None = None, aad: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def try_aes_decrypt(input: Column[In, Out], key: Column[In, Out], mode: Column[In, Out] | None = None, padding: Column[In, Out] | None = None, aad: Column[In, Out] | None = None) -> Column[In, Literal['expr']]: ...
def sha(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def input_file_block_length() -> Column[In, Literal['expr']]: ...
def input_file_block_start() -> Column[In, Literal['expr']]: ...
def reflect(*cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def java_method(*cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def version() -> Column[In, Literal['expr']]: ...
def typeof(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def stack(*cols: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def bitmap_bit_position(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def bitmap_bucket_number(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def bitmap_construct_agg(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def bitmap_count(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
def bitmap_or_agg(col: Column[In, Out]) -> Column[In, Literal['expr']]: ...
@overload
def udf(f: Callable[..., Any], returnType: DataTypeOrString = ..., *, useArrow: bool | None = None) -> UserDefinedFunctionLike: ...
@overload
def udf(f: DataTypeOrString | None = None, *, useArrow: bool | None = None) -> Callable[[Callable[..., Any]], 'UserDefinedFunctionLike']: ...
@overload
def udf(*, returnType: DataTypeOrString = ..., useArrow: bool | None = None) -> Callable[[Callable[..., Any]], 'UserDefinedFunctionLike']: ...
def udtf(cls: Incomplete | None = None, *, returnType: StructType | str, useArrow: bool | None = None) -> UserDefinedTableFunction | Callable[[type], 'UserDefinedTableFunction']: ...

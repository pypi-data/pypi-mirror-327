import numpy as np
from _typeshed import Incomplete
from pyspark.context import SparkContext
from pyspark.mllib._typing import VectorLike
from pyspark.mllib.linalg import Vector
from pyspark.mllib.util import Loader, Saveable
from pyspark.rdd import RDD
from pyspark.streaming.dstream import DStream
from typing import Iterable, TypeVar, overload

__all__ = ['LabeledPoint', 'LinearModel', 'LinearRegressionModel', 'LinearRegressionWithSGD', 'RidgeRegressionModel', 'RidgeRegressionWithSGD', 'LassoModel', 'LassoWithSGD', 'IsotonicRegressionModel', 'IsotonicRegression', 'StreamingLinearAlgorithm', 'StreamingLinearRegressionWithSGD']

LM = TypeVar('LM')
K = TypeVar('K')

class LabeledPoint:
    label: Incomplete
    features: Incomplete
    def __init__(self, label: float, features: Iterable[float]) -> None: ...
    def __reduce__(self) -> tuple[type['LabeledPoint'], tuple[float, Vector]]: ...

class LinearModel:
    def __init__(self, weights: Vector, intercept: float) -> None: ...
    @property
    def weights(self) -> Vector: ...
    @property
    def intercept(self) -> float: ...

class LinearRegressionModelBase(LinearModel):
    @overload
    def predict(self, x: VectorLike) -> float: ...
    @overload
    def predict(self, x: RDD['VectorLike']) -> RDD[float]: ...

class LinearRegressionModel(LinearRegressionModelBase):
    def save(self, sc: SparkContext, path: str) -> None: ...
    @classmethod
    def load(cls, sc: SparkContext, path: str) -> LinearRegressionModel: ...

class LinearRegressionWithSGD:
    @classmethod
    def train(cls, data: RDD[LabeledPoint], iterations: int = 100, step: float = 1.0, miniBatchFraction: float = 1.0, initialWeights: VectorLike | None = None, regParam: float = 0.0, regType: str | None = None, intercept: bool = False, validateData: bool = True, convergenceTol: float = 0.001) -> LinearRegressionModel: ...

class LassoModel(LinearRegressionModelBase):
    def save(self, sc: SparkContext, path: str) -> None: ...
    @classmethod
    def load(cls, sc: SparkContext, path: str) -> LassoModel: ...

class LassoWithSGD:
    @classmethod
    def train(cls, data: RDD[LabeledPoint], iterations: int = 100, step: float = 1.0, regParam: float = 0.01, miniBatchFraction: float = 1.0, initialWeights: VectorLike | None = None, intercept: bool = False, validateData: bool = True, convergenceTol: float = 0.001) -> LassoModel: ...

class RidgeRegressionModel(LinearRegressionModelBase):
    def save(self, sc: SparkContext, path: str) -> None: ...
    @classmethod
    def load(cls, sc: SparkContext, path: str) -> RidgeRegressionModel: ...

class RidgeRegressionWithSGD:
    @classmethod
    def train(cls, data: RDD[LabeledPoint], iterations: int = 100, step: float = 1.0, regParam: float = 0.01, miniBatchFraction: float = 1.0, initialWeights: VectorLike | None = None, intercept: bool = False, validateData: bool = True, convergenceTol: float = 0.001) -> RidgeRegressionModel: ...

class IsotonicRegressionModel(Saveable, Loader['IsotonicRegressionModel']):
    boundaries: Incomplete
    predictions: Incomplete
    isotonic: Incomplete
    def __init__(self, boundaries: np.ndarray, predictions: np.ndarray, isotonic: bool) -> None: ...
    @overload
    def predict(self, x: float) -> np.float64: ...
    @overload
    def predict(self, x: VectorLike) -> np.ndarray: ...
    @overload
    def predict(self, x: RDD[float]) -> RDD[np.float64]: ...
    @overload
    def predict(self, x: RDD['VectorLike']) -> RDD[np.ndarray]: ...
    def save(self, sc: SparkContext, path: str) -> None: ...
    @classmethod
    def load(cls, sc: SparkContext, path: str) -> IsotonicRegressionModel: ...

class IsotonicRegression:
    @classmethod
    def train(cls, data: RDD['VectorLike'], isotonic: bool = True) -> IsotonicRegressionModel: ...

class StreamingLinearAlgorithm:
    def __init__(self, model: LinearModel | None) -> None: ...
    def latestModel(self) -> LinearModel | None: ...
    def predictOn(self, dstream: DStream[VectorLike]) -> DStream[float]: ...
    def predictOnValues(self, dstream: DStream[tuple[K, VectorLike]]) -> DStream[tuple[K, float]]: ...

class StreamingLinearRegressionWithSGD(StreamingLinearAlgorithm):
    stepSize: Incomplete
    numIterations: Incomplete
    miniBatchFraction: Incomplete
    convergenceTol: Incomplete
    def __init__(self, stepSize: float = 0.1, numIterations: int = 50, miniBatchFraction: float = 1.0, convergenceTol: float = 0.001) -> None: ...
    def setInitialWeights(self, initialWeights: VectorLike) -> StreamingLinearRegressionWithSGD: ...
    def trainOn(self, dstream: DStream[LabeledPoint]) -> None: ...

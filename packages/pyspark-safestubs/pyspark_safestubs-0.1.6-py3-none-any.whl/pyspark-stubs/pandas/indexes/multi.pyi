import pandas as pd
from _typeshed import Incomplete
from pyspark.pandas._typing import Label as Label, Name as Name, Scalar as Scalar
from pyspark.pandas.exceptions import PandasNotImplementedError as PandasNotImplementedError
from pyspark.pandas.frame import DataFrame as DataFrame
from pyspark.pandas.indexes.base import Index as Index
from pyspark.pandas.internal import InternalField as InternalField, InternalFrame as InternalFrame, NATURAL_ORDER_COLUMN_NAME as NATURAL_ORDER_COLUMN_NAME, SPARK_INDEX_NAME_FORMAT as SPARK_INDEX_NAME_FORMAT
from pyspark.pandas.missing.indexes import MissingPandasLikeMultiIndex as MissingPandasLikeMultiIndex
from pyspark.pandas.series import Series as Series, first_series as first_series
from pyspark.pandas.utils import compare_disallow_null as compare_disallow_null, is_name_like_tuple as is_name_like_tuple, name_like_string as name_like_string, scol_for as scol_for, validate_index_loc as validate_index_loc, verify_temp_column_name as verify_temp_column_name
from pyspark.sql import Window as Window
from pyspark.sql.types import DataType as DataType
from pyspark.sql.utils import get_column_class as get_column_class
from typing import Any, Callable, Iterator

class MultiIndex(Index):
    def __new__(cls, levels: Incomplete | None = None, codes: Incomplete | None = None, sortorder: Incomplete | None = None, names: Incomplete | None = None, dtype: Incomplete | None = None, copy: bool = False, name: Incomplete | None = None, verify_integrity: bool = True): ...
    def __abs__(self) -> MultiIndex: ...
    def any(self, *args, **kwargs) -> None: ...
    def all(self, *args, **kwargs) -> None: ...
    @staticmethod
    def from_tuples(tuples: list[tuple], sortorder: int | None = None, names: list[Name] | None = None) -> MultiIndex: ...
    @staticmethod
    def from_arrays(arrays: list[list], sortorder: int | None = None, names: list[Name] | None = None) -> MultiIndex: ...
    @staticmethod
    def from_product(iterables: list[list], sortorder: int | None = None, names: list[Name] | None = None) -> MultiIndex: ...
    @staticmethod
    def from_frame(df: DataFrame, names: list[Name] | None = None) -> MultiIndex: ...
    @property
    def name(self) -> Name: ...
    @name.setter
    def name(self, name: Name) -> None: ...
    @property
    def dtypes(self) -> pd.Series: ...
    def swaplevel(self, i: int = -2, j: int = -1) -> MultiIndex: ...
    @property
    def levshape(self) -> tuple[int, ...]: ...
    def to_frame(self, index: bool = True, name: list[Name] | None = None) -> DataFrame: ...
    def to_pandas(self) -> pd.MultiIndex: ...
    def nunique(self, dropna: bool = True, approx: bool = False, rsd: float = 0.05) -> int: ...
    def copy(self, deep: bool | None = None) -> MultiIndex: ...
    def symmetric_difference(self, other: Index, result_name: list[Name] | None = None, sort: bool | None = None) -> MultiIndex: ...
    def drop(self, codes: list[Any], level: int | Name | None = None) -> MultiIndex: ...
    def drop_duplicates(self, keep: bool | str = 'first') -> MultiIndex: ...
    def argmax(self) -> None: ...
    def argmin(self) -> None: ...
    def asof(self, label: Any) -> None: ...
    @property
    def is_all_dates(self) -> bool: ...
    def __getattr__(self, item: str) -> Any: ...
    def get_level_values(self, level: int | Name) -> Index: ...
    def insert(self, loc: int, item: Any) -> Index: ...
    def item(self) -> tuple[Scalar, ...]: ...
    def intersection(self, other: DataFrame | Series | Index | list) -> MultiIndex: ...
    def equal_levels(self, other: MultiIndex) -> bool: ...
    @property
    def hasnans(self) -> bool: ...
    @property
    def inferred_type(self) -> str: ...
    @property
    def asi8(self) -> None: ...
    def factorize(self, sort: bool = True, na_sentinel: int | None = -1) -> tuple['MultiIndex', pd.Index]: ...
    def __iter__(self) -> Iterator: ...
    def map(self, mapper: dict | Callable[[Any], Any] | pd.Series = None, na_action: str | None = None) -> Index: ...

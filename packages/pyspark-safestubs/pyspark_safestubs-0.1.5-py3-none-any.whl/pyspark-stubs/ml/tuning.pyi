from _typeshed import Incomplete
from py4j.java_collections import JavaArray
from pyspark import SparkContext
from pyspark.ml import Estimator, Model
from pyspark.ml._typing import ParamMap
from pyspark.ml.evaluation import Evaluator
from pyspark.ml.param import Param
from pyspark.ml.param.shared import HasCollectSubModels, HasParallelism, HasSeed
from pyspark.ml.util import MLReadable, MLReader, MLWritable, MLWriter
from typing import Any, Sequence, overload

__all__ = ['ParamGridBuilder', 'CrossValidator', 'CrossValidatorModel', 'TrainValidationSplit', 'TrainValidationSplitModel']

class ParamGridBuilder:
    def __init__(self) -> None: ...
    def addGrid(self, param: Param[Any], values: list[Any]) -> ParamGridBuilder: ...
    @overload
    def baseOn(self, /, __args: ParamMap) -> ParamGridBuilder: ...
    @overload
    def baseOn(self, *args: tuple[Param, Any]) -> ParamGridBuilder: ...
    def build(self) -> list['ParamMap']: ...

class _ValidatorParams(HasSeed):
    estimator: Param[Estimator]
    estimatorParamMaps: Param[list['ParamMap']]
    evaluator: Param[Evaluator]
    def getEstimator(self) -> Estimator: ...
    def getEstimatorParamMaps(self) -> list['ParamMap']: ...
    def getEvaluator(self) -> Evaluator: ...

class _ValidatorSharedReadWrite:
    @staticmethod
    def meta_estimator_transfer_param_maps_to_java(pyEstimator: Estimator, pyParamMaps: Sequence['ParamMap']) -> JavaArray: ...
    @staticmethod
    def meta_estimator_transfer_param_maps_from_java(pyEstimator: Estimator, javaParamMaps: JavaArray) -> list['ParamMap']: ...
    @staticmethod
    def is_java_convertible(instance: _ValidatorParams) -> bool: ...
    @staticmethod
    def saveImpl(path: str, instance: _ValidatorParams, sc: SparkContext, extraMetadata: dict[str, Any] | None = None) -> None: ...
    @staticmethod
    def load(path: str, sc: SparkContext, metadata: dict[str, Any]) -> tuple[dict[str, Any], Estimator, Evaluator, list['ParamMap']]: ...
    @staticmethod
    def validateParams(instance: _ValidatorParams) -> None: ...
    @staticmethod
    def getValidatorModelWriterPersistSubModelsParam(writer: MLWriter) -> bool: ...

class CrossValidatorReader(MLReader['CrossValidator']):
    cls: Incomplete
    def __init__(self, cls: type['CrossValidator']) -> None: ...
    def load(self, path: str) -> CrossValidator: ...

class CrossValidatorWriter(MLWriter):
    instance: Incomplete
    def __init__(self, instance: CrossValidator) -> None: ...
    def saveImpl(self, path: str) -> None: ...

class CrossValidatorModelReader(MLReader['CrossValidatorModel']):
    cls: Incomplete
    def __init__(self, cls: type['CrossValidatorModel']) -> None: ...
    def load(self, path: str) -> CrossValidatorModel: ...

class CrossValidatorModelWriter(MLWriter):
    instance: Incomplete
    def __init__(self, instance: CrossValidatorModel) -> None: ...
    def saveImpl(self, path: str) -> None: ...

class _CrossValidatorParams(_ValidatorParams):
    numFolds: Param[int]
    foldCol: Param[str]
    def __init__(self, *args: Any) -> None: ...
    def getNumFolds(self) -> int: ...
    def getFoldCol(self) -> str: ...

class CrossValidator(Estimator['CrossValidatorModel'], _CrossValidatorParams, HasParallelism, HasCollectSubModels, MLReadable['CrossValidator'], MLWritable):
    def __init__(self, *, estimator: Estimator | None = None, estimatorParamMaps: list['ParamMap'] | None = None, evaluator: Evaluator | None = None, numFolds: int = 3, seed: int | None = None, parallelism: int = 1, collectSubModels: bool = False, foldCol: str = '') -> None: ...
    def setParams(self, *, estimator: Estimator | None = None, estimatorParamMaps: list['ParamMap'] | None = None, evaluator: Evaluator | None = None, numFolds: int = 3, seed: int | None = None, parallelism: int = 1, collectSubModels: bool = False, foldCol: str = '') -> CrossValidator: ...
    def setEstimator(self, value: Estimator) -> CrossValidator: ...
    def setEstimatorParamMaps(self, value: list['ParamMap']) -> CrossValidator: ...
    def setEvaluator(self, value: Evaluator) -> CrossValidator: ...
    def setNumFolds(self, value: int) -> CrossValidator: ...
    def setFoldCol(self, value: str) -> CrossValidator: ...
    def setSeed(self, value: int) -> CrossValidator: ...
    def setParallelism(self, value: int) -> CrossValidator: ...
    def setCollectSubModels(self, value: bool) -> CrossValidator: ...
    def copy(self, extra: ParamMap | None = None) -> CrossValidator: ...
    def write(self) -> MLWriter: ...
    @classmethod
    def read(cls) -> CrossValidatorReader: ...

class CrossValidatorModel(Model, _CrossValidatorParams, MLReadable['CrossValidatorModel'], MLWritable):
    bestModel: Incomplete
    avgMetrics: Incomplete
    subModels: Incomplete
    stdMetrics: Incomplete
    def __init__(self, bestModel: Model, avgMetrics: list[float] | None = None, subModels: list[list[Model]] | None = None, stdMetrics: list[float] | None = None) -> None: ...
    def copy(self, extra: ParamMap | None = None) -> CrossValidatorModel: ...
    def write(self) -> MLWriter: ...
    @classmethod
    def read(cls) -> CrossValidatorModelReader: ...

class TrainValidationSplitReader(MLReader['TrainValidationSplit']):
    cls: Incomplete
    def __init__(self, cls: type['TrainValidationSplit']) -> None: ...
    def load(self, path: str) -> TrainValidationSplit: ...

class TrainValidationSplitWriter(MLWriter):
    instance: Incomplete
    def __init__(self, instance: TrainValidationSplit) -> None: ...
    def saveImpl(self, path: str) -> None: ...

class TrainValidationSplitModelReader(MLReader['TrainValidationSplitModel']):
    cls: Incomplete
    def __init__(self, cls: type['TrainValidationSplitModel']) -> None: ...
    def load(self, path: str) -> TrainValidationSplitModel: ...

class TrainValidationSplitModelWriter(MLWriter):
    instance: Incomplete
    def __init__(self, instance: TrainValidationSplitModel) -> None: ...
    def saveImpl(self, path: str) -> None: ...

class _TrainValidationSplitParams(_ValidatorParams):
    trainRatio: Param[float]
    def __init__(self, *args: Any) -> None: ...
    def getTrainRatio(self) -> float: ...

class TrainValidationSplit(Estimator['TrainValidationSplitModel'], _TrainValidationSplitParams, HasParallelism, HasCollectSubModels, MLReadable['TrainValidationSplit'], MLWritable):
    def __init__(self, *, estimator: Estimator | None = None, estimatorParamMaps: list['ParamMap'] | None = None, evaluator: Evaluator | None = None, trainRatio: float = 0.75, parallelism: int = 1, collectSubModels: bool = False, seed: int | None = None) -> None: ...
    def setParams(self, *, estimator: Estimator | None = None, estimatorParamMaps: list['ParamMap'] | None = None, evaluator: Evaluator | None = None, trainRatio: float = 0.75, parallelism: int = 1, collectSubModels: bool = False, seed: int | None = None) -> TrainValidationSplit: ...
    def setEstimator(self, value: Estimator) -> TrainValidationSplit: ...
    def setEstimatorParamMaps(self, value: list['ParamMap']) -> TrainValidationSplit: ...
    def setEvaluator(self, value: Evaluator) -> TrainValidationSplit: ...
    def setTrainRatio(self, value: float) -> TrainValidationSplit: ...
    def setSeed(self, value: int) -> TrainValidationSplit: ...
    def setParallelism(self, value: int) -> TrainValidationSplit: ...
    def setCollectSubModels(self, value: bool) -> TrainValidationSplit: ...
    def copy(self, extra: ParamMap | None = None) -> TrainValidationSplit: ...
    def write(self) -> MLWriter: ...
    @classmethod
    def read(cls) -> TrainValidationSplitReader: ...

class TrainValidationSplitModel(Model, _TrainValidationSplitParams, MLReadable['TrainValidationSplitModel'], MLWritable):
    bestModel: Incomplete
    validationMetrics: Incomplete
    subModels: Incomplete
    def __init__(self, bestModel: Model, validationMetrics: list[float] | None = None, subModels: list[Model] | None = None) -> None: ...
    def copy(self, extra: ParamMap | None = None) -> TrainValidationSplitModel: ...
    def write(self) -> MLWriter: ...
    @classmethod
    def read(cls) -> TrainValidationSplitModelReader: ...

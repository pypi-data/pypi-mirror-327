from _typeshed import Incomplete
from pyspark.errors import PySparkTypeError as PySparkTypeError, PySparkValueError as PySparkValueError
from pyspark.sql.connect._typing import ColumnOrName as ColumnOrName, DataTypeOrString as DataTypeOrString, UserDefinedFunctionLike as UserDefinedFunctionLike
from pyspark.sql.connect.column import Column as Column
from pyspark.sql.connect.dataframe import DataFrame as DataFrame
from pyspark.sql.connect.expressions import CallFunction as CallFunction, CaseWhen as CaseWhen, ColumnReference as ColumnReference, Expression as Expression, LambdaFunction as LambdaFunction, LiteralExpression as LiteralExpression, SQLExpression as SQLExpression, UnresolvedFunction as UnresolvedFunction, UnresolvedNamedLambdaVariable as UnresolvedNamedLambdaVariable, UnresolvedStar as UnresolvedStar
from pyspark.sql.connect.udtf import UserDefinedTableFunction as UserDefinedTableFunction
from pyspark.sql.connect.utils import check_dependencies as check_dependencies
from pyspark.sql.functions import pandas_udf as pandas_udf
from pyspark.sql.types import ArrayType as ArrayType, DataType as DataType, StringType as StringType, StructType as StructType
from typing import Any, Callable, overload

def col(col: str) -> Column: ...
column = col

def lit(col: Any) -> Column: ...
def bitwiseNOT(col: ColumnOrName) -> Column: ...
def bitwise_not(col: ColumnOrName) -> Column: ...
def bit_count(col: ColumnOrName) -> Column: ...
def bit_get(col: ColumnOrName, pos: ColumnOrName) -> Column: ...
def getbit(col: ColumnOrName, pos: ColumnOrName) -> Column: ...
def broadcast(df: DataFrame) -> DataFrame: ...
def coalesce(*cols: ColumnOrName) -> Column: ...
def expr(str: str) -> Column: ...
def greatest(*cols: ColumnOrName) -> Column: ...
def input_file_name() -> Column: ...
def least(*cols: ColumnOrName) -> Column: ...
def isnan(col: ColumnOrName) -> Column: ...
def isnull(col: ColumnOrName) -> Column: ...
def monotonically_increasing_id() -> Column: ...
def nanvl(col1: ColumnOrName, col2: ColumnOrName) -> Column: ...
def rand(seed: int | None = None) -> Column: ...
def randn(seed: int | None = None) -> Column: ...
def spark_partition_id() -> Column: ...
def when(condition: Column, value: Any) -> Column: ...
def asc(col: ColumnOrName) -> Column: ...
def asc_nulls_first(col: ColumnOrName) -> Column: ...
def asc_nulls_last(col: ColumnOrName) -> Column: ...
def desc(col: ColumnOrName) -> Column: ...
def desc_nulls_first(col: ColumnOrName) -> Column: ...
def desc_nulls_last(col: ColumnOrName) -> Column: ...
def abs(col: ColumnOrName) -> Column: ...
def acos(col: ColumnOrName) -> Column: ...
def acosh(col: ColumnOrName) -> Column: ...
def asin(col: ColumnOrName) -> Column: ...
def asinh(col: ColumnOrName) -> Column: ...
def atan(col: ColumnOrName) -> Column: ...
def atan2(col1: ColumnOrName | float, col2: ColumnOrName | float) -> Column: ...
def atanh(col: ColumnOrName) -> Column: ...
def bin(col: ColumnOrName) -> Column: ...
def bround(col: ColumnOrName, scale: int = 0) -> Column: ...
def cbrt(col: ColumnOrName) -> Column: ...
def ceil(col: ColumnOrName) -> Column: ...
def ceiling(col: ColumnOrName) -> Column: ...
def conv(col: ColumnOrName, fromBase: int, toBase: int) -> Column: ...
def cos(col: ColumnOrName) -> Column: ...
def cosh(col: ColumnOrName) -> Column: ...
def cot(col: ColumnOrName) -> Column: ...
def csc(col: ColumnOrName) -> Column: ...
def degrees(col: ColumnOrName) -> Column: ...
def e() -> Column: ...
def exp(col: ColumnOrName) -> Column: ...
def expm1(col: ColumnOrName) -> Column: ...
def factorial(col: ColumnOrName) -> Column: ...
def floor(col: ColumnOrName) -> Column: ...
def hex(col: ColumnOrName) -> Column: ...
def hypot(col1: ColumnOrName | float, col2: ColumnOrName | float) -> Column: ...
def log(arg1: ColumnOrName | float, arg2: ColumnOrName | None = None) -> Column: ...
def log10(col: ColumnOrName) -> Column: ...
def log1p(col: ColumnOrName) -> Column: ...
def ln(col: ColumnOrName) -> Column: ...
def log2(col: ColumnOrName) -> Column: ...
def negative(col: ColumnOrName) -> Column: ...
negate = negative

def pi() -> Column: ...
def positive(col: ColumnOrName) -> Column: ...
def pmod(dividend: ColumnOrName | float, divisor: ColumnOrName | float) -> Column: ...
def width_bucket(v: ColumnOrName, min: ColumnOrName, max: ColumnOrName, numBucket: ColumnOrName | int) -> Column: ...
def pow(col1: ColumnOrName | float, col2: ColumnOrName | float) -> Column: ...
def radians(col: ColumnOrName) -> Column: ...
def rint(col: ColumnOrName) -> Column: ...
def round(col: ColumnOrName, scale: int = 0) -> Column: ...
def sec(col: ColumnOrName) -> Column: ...
def shiftLeft(col: ColumnOrName, numBits: int) -> Column: ...
def shiftleft(col: ColumnOrName, numBits: int) -> Column: ...
def shiftRight(col: ColumnOrName, numBits: int) -> Column: ...
def shiftright(col: ColumnOrName, numBits: int) -> Column: ...
def shiftRightUnsigned(col: ColumnOrName, numBits: int) -> Column: ...
def shiftrightunsigned(col: ColumnOrName, numBits: int) -> Column: ...
def signum(col: ColumnOrName) -> Column: ...
def sign(col: ColumnOrName) -> Column: ...
def sin(col: ColumnOrName) -> Column: ...
def sinh(col: ColumnOrName) -> Column: ...
def sqrt(col: ColumnOrName) -> Column: ...
def try_add(left: ColumnOrName, right: ColumnOrName) -> Column: ...
def try_avg(col: ColumnOrName) -> Column: ...
def try_divide(left: ColumnOrName, right: ColumnOrName) -> Column: ...
def try_multiply(left: ColumnOrName, right: ColumnOrName) -> Column: ...
def try_subtract(left: ColumnOrName, right: ColumnOrName) -> Column: ...
def try_sum(col: ColumnOrName) -> Column: ...
def tan(col: ColumnOrName) -> Column: ...
def tanh(col: ColumnOrName) -> Column: ...
def toDegrees(col: ColumnOrName) -> Column: ...
def toRadians(col: ColumnOrName) -> Column: ...
def unhex(col: ColumnOrName) -> Column: ...
def approxCountDistinct(col: ColumnOrName, rsd: float | None = None) -> Column: ...
def approx_count_distinct(col: ColumnOrName, rsd: float | None = None) -> Column: ...
def avg(col: ColumnOrName) -> Column: ...
def collect_list(col: ColumnOrName) -> Column: ...
def array_agg(col: ColumnOrName) -> Column: ...
def collect_set(col: ColumnOrName) -> Column: ...
def corr(col1: ColumnOrName, col2: ColumnOrName) -> Column: ...
def count(col: ColumnOrName) -> Column: ...
def countDistinct(col: ColumnOrName, *cols: ColumnOrName) -> Column: ...
def count_distinct(col: ColumnOrName, *cols: ColumnOrName) -> Column: ...
def covar_pop(col1: ColumnOrName, col2: ColumnOrName) -> Column: ...
def covar_samp(col1: ColumnOrName, col2: ColumnOrName) -> Column: ...
def first(col: ColumnOrName, ignorenulls: bool = False) -> Column: ...
def grouping(col: ColumnOrName) -> Column: ...
def grouping_id(*cols: ColumnOrName) -> Column: ...
def count_min_sketch(col: ColumnOrName, eps: ColumnOrName, confidence: ColumnOrName, seed: ColumnOrName) -> Column: ...
def kurtosis(col: ColumnOrName) -> Column: ...
def last(col: ColumnOrName, ignorenulls: bool = False) -> Column: ...
def max(col: ColumnOrName) -> Column: ...
def max_by(col: ColumnOrName, ord: ColumnOrName) -> Column: ...
def mean(col: ColumnOrName) -> Column: ...
def median(col: ColumnOrName) -> Column: ...
def min(col: ColumnOrName) -> Column: ...
def min_by(col: ColumnOrName, ord: ColumnOrName) -> Column: ...
def mode(col: ColumnOrName) -> Column: ...
def percentile(col: ColumnOrName, percentage: Column | float | list[float] | tuple[float], frequency: Column | int = 1) -> Column: ...
def percentile_approx(col: ColumnOrName, percentage: Column | float | list[float] | tuple[float], accuracy: Column | float = 10000) -> Column: ...
def approx_percentile(col: ColumnOrName, percentage: Column | float | list[float] | tuple[float], accuracy: Column | float = 10000) -> Column: ...
def product(col: ColumnOrName) -> Column: ...
def skewness(col: ColumnOrName) -> Column: ...
def stddev(col: ColumnOrName) -> Column: ...
def std(col: ColumnOrName) -> Column: ...
def stddev_samp(col: ColumnOrName) -> Column: ...
def stddev_pop(col: ColumnOrName) -> Column: ...
def sum(col: ColumnOrName) -> Column: ...
def sumDistinct(col: ColumnOrName) -> Column: ...
def sum_distinct(col: ColumnOrName) -> Column: ...
def var_pop(col: ColumnOrName) -> Column: ...
def regr_avgx(y: ColumnOrName, x: ColumnOrName) -> Column: ...
def regr_avgy(y: ColumnOrName, x: ColumnOrName) -> Column: ...
def regr_count(y: ColumnOrName, x: ColumnOrName) -> Column: ...
def regr_intercept(y: ColumnOrName, x: ColumnOrName) -> Column: ...
def regr_r2(y: ColumnOrName, x: ColumnOrName) -> Column: ...
def regr_slope(y: ColumnOrName, x: ColumnOrName) -> Column: ...
def regr_sxx(y: ColumnOrName, x: ColumnOrName) -> Column: ...
def regr_sxy(y: ColumnOrName, x: ColumnOrName) -> Column: ...
def regr_syy(y: ColumnOrName, x: ColumnOrName) -> Column: ...
def var_samp(col: ColumnOrName) -> Column: ...
def variance(col: ColumnOrName) -> Column: ...
def every(col: ColumnOrName) -> Column: ...
def bool_and(col: ColumnOrName) -> Column: ...
def some(col: ColumnOrName) -> Column: ...
def bool_or(col: ColumnOrName) -> Column: ...
def bit_and(col: ColumnOrName) -> Column: ...
def bit_or(col: ColumnOrName) -> Column: ...
def bit_xor(col: ColumnOrName) -> Column: ...
def cume_dist() -> Column: ...
def dense_rank() -> Column: ...
def lag(col: ColumnOrName, offset: int = 1, default: Any | None = None) -> Column: ...
def lead(col: ColumnOrName, offset: int = 1, default: Any | None = None) -> Column: ...
def nth_value(col: ColumnOrName, offset: int, ignoreNulls: bool | None = None) -> Column: ...
def any_value(col: ColumnOrName, ignoreNulls: bool | Column | None = None) -> Column: ...
def first_value(col: ColumnOrName, ignoreNulls: bool | Column | None = None) -> Column: ...
def last_value(col: ColumnOrName, ignoreNulls: bool | Column | None = None) -> Column: ...
def count_if(col: ColumnOrName) -> Column: ...
def histogram_numeric(col: ColumnOrName, nBins: ColumnOrName) -> Column: ...
def ntile(n: int) -> Column: ...
def percent_rank() -> Column: ...
def rank() -> Column: ...
def row_number() -> Column: ...
def aggregate(col: ColumnOrName, initialValue: ColumnOrName, merge: Callable[[Column, Column], Column], finish: Callable[[Column], Column] | None = None) -> Column: ...
def reduce(col: ColumnOrName, initialValue: ColumnOrName, merge: Callable[[Column, Column], Column], finish: Callable[[Column], Column] | None = None) -> Column: ...
def array(*cols: ColumnOrName | list['ColumnOrName'] | tuple['ColumnOrName', ...]) -> Column: ...
def array_append(col: ColumnOrName, value: Any) -> Column: ...
def array_contains(col: ColumnOrName, value: Any) -> Column: ...
def array_distinct(col: ColumnOrName) -> Column: ...
def array_except(col1: ColumnOrName, col2: ColumnOrName) -> Column: ...
def array_insert(arr: ColumnOrName, pos: ColumnOrName | int, value: Any) -> Column: ...
def array_intersect(col1: ColumnOrName, col2: ColumnOrName) -> Column: ...
def array_compact(col: ColumnOrName) -> Column: ...
def array_join(col: ColumnOrName, delimiter: str, null_replacement: str | None = None) -> Column: ...
def array_max(col: ColumnOrName) -> Column: ...
def array_min(col: ColumnOrName) -> Column: ...
def array_size(col: ColumnOrName) -> Column: ...
def cardinality(col: ColumnOrName) -> Column: ...
def array_position(col: ColumnOrName, value: Any) -> Column: ...
def array_prepend(col: ColumnOrName, value: Any) -> Column: ...
def array_remove(col: ColumnOrName, element: Any) -> Column: ...
def array_repeat(col: ColumnOrName, count: ColumnOrName | int) -> Column: ...
def array_sort(col: ColumnOrName, comparator: Callable[[Column, Column], Column] | None = None) -> Column: ...
def array_union(col1: ColumnOrName, col2: ColumnOrName) -> Column: ...
def arrays_overlap(a1: ColumnOrName, a2: ColumnOrName) -> Column: ...
def arrays_zip(*cols: ColumnOrName) -> Column: ...
def concat(*cols: ColumnOrName) -> Column: ...
def create_map(*cols: ColumnOrName | list['ColumnOrName'] | tuple['ColumnOrName', ...]) -> Column: ...
def element_at(col: ColumnOrName, extraction: Any) -> Column: ...
def try_element_at(col: ColumnOrName, extraction: ColumnOrName) -> Column: ...
def exists(col: ColumnOrName, f: Callable[[Column], Column]) -> Column: ...
def explode(col: ColumnOrName) -> Column: ...
def explode_outer(col: ColumnOrName) -> Column: ...
def filter(col: ColumnOrName, f: Callable[[Column], Column] | Callable[[Column, Column], Column]) -> Column: ...
def flatten(col: ColumnOrName) -> Column: ...
def forall(col: ColumnOrName, f: Callable[[Column], Column]) -> Column: ...
def from_csv(col: ColumnOrName, schema: Column | str, options: dict[str, str] | None = None) -> Column: ...
def from_json(col: ColumnOrName, schema: ArrayType | StructType | Column | str, options: dict[str, str] | None = None) -> Column: ...
def get(col: ColumnOrName, index: ColumnOrName | int) -> Column: ...
def get_json_object(col: ColumnOrName, path: str) -> Column: ...
def json_array_length(col: ColumnOrName) -> Column: ...
def json_object_keys(col: ColumnOrName) -> Column: ...
def inline(col: ColumnOrName) -> Column: ...
def inline_outer(col: ColumnOrName) -> Column: ...
def json_tuple(col: ColumnOrName, *fields: str) -> Column: ...
def map_concat(*cols: ColumnOrName | list['ColumnOrName'] | tuple['ColumnOrName', ...]) -> Column: ...
def map_contains_key(col: ColumnOrName, value: Any) -> Column: ...
def map_entries(col: ColumnOrName) -> Column: ...
def map_filter(col: ColumnOrName, f: Callable[[Column, Column], Column]) -> Column: ...
def map_from_arrays(col1: ColumnOrName, col2: ColumnOrName) -> Column: ...
def map_from_entries(col: ColumnOrName) -> Column: ...
def map_keys(col: ColumnOrName) -> Column: ...
def map_values(col: ColumnOrName) -> Column: ...
def map_zip_with(col1: ColumnOrName, col2: ColumnOrName, f: Callable[[Column, Column, Column], Column]) -> Column: ...
def str_to_map(text: ColumnOrName, pairDelim: ColumnOrName | None = None, keyValueDelim: ColumnOrName | None = None) -> Column: ...
def posexplode(col: ColumnOrName) -> Column: ...
def posexplode_outer(col: ColumnOrName) -> Column: ...
def reverse(col: ColumnOrName) -> Column: ...
def sequence(start: ColumnOrName, stop: ColumnOrName, step: ColumnOrName | None = None) -> Column: ...
def schema_of_csv(csv: ColumnOrName, options: dict[str, str] | None = None) -> Column: ...
def schema_of_json(json: ColumnOrName, options: dict[str, str] | None = None) -> Column: ...
def shuffle(col: ColumnOrName) -> Column: ...
def size(col: ColumnOrName) -> Column: ...
def slice(col: ColumnOrName, start: ColumnOrName | int, length: ColumnOrName | int) -> Column: ...
def sort_array(col: ColumnOrName, asc: bool = True) -> Column: ...
def struct(*cols: ColumnOrName | list['ColumnOrName'] | tuple['ColumnOrName', ...]) -> Column: ...
def named_struct(*cols: ColumnOrName) -> Column: ...
def to_csv(col: ColumnOrName, options: dict[str, str] | None = None) -> Column: ...
def to_json(col: ColumnOrName, options: dict[str, str] | None = None) -> Column: ...
def transform(col: ColumnOrName, f: Callable[[Column], Column] | Callable[[Column, Column], Column]) -> Column: ...
def transform_keys(col: ColumnOrName, f: Callable[[Column, Column], Column]) -> Column: ...
def transform_values(col: ColumnOrName, f: Callable[[Column, Column], Column]) -> Column: ...
def zip_with(left: ColumnOrName, right: ColumnOrName, f: Callable[[Column, Column], Column]) -> Column: ...
def upper(col: ColumnOrName) -> Column: ...
def lower(col: ColumnOrName) -> Column: ...
def ascii(col: ColumnOrName) -> Column: ...
def base64(col: ColumnOrName) -> Column: ...
def unbase64(col: ColumnOrName) -> Column: ...
def ltrim(col: ColumnOrName) -> Column: ...
def rtrim(col: ColumnOrName) -> Column: ...
def trim(col: ColumnOrName) -> Column: ...
def concat_ws(sep: str, *cols: ColumnOrName) -> Column: ...
def decode(col: ColumnOrName, charset: str) -> Column: ...
def encode(col: ColumnOrName, charset: str) -> Column: ...
def format_number(col: ColumnOrName, d: int) -> Column: ...
def format_string(format: str, *cols: ColumnOrName) -> Column: ...
def instr(str: ColumnOrName, substr: str) -> Column: ...
def overlay(src: ColumnOrName, replace: ColumnOrName, pos: ColumnOrName | int, len: ColumnOrName | int = -1) -> Column: ...
def sentences(string: ColumnOrName, language: ColumnOrName | None = None, country: ColumnOrName | None = None) -> Column: ...
def substring(str: ColumnOrName, pos: int, len: int) -> Column: ...
def substring_index(str: ColumnOrName, delim: str, count: int) -> Column: ...
def levenshtein(left: ColumnOrName, right: ColumnOrName, threshold: int | None = None) -> Column: ...
def locate(substr: str, str: ColumnOrName, pos: int = 1) -> Column: ...
def lpad(col: ColumnOrName, len: int, pad: str) -> Column: ...
def rpad(col: ColumnOrName, len: int, pad: str) -> Column: ...
def repeat(col: ColumnOrName, n: int) -> Column: ...
def split(str: ColumnOrName, pattern: str, limit: int = -1) -> Column: ...
def rlike(str: ColumnOrName, regexp: ColumnOrName) -> Column: ...
def regexp(str: ColumnOrName, regexp: ColumnOrName) -> Column: ...
def regexp_like(str: ColumnOrName, regexp: ColumnOrName) -> Column: ...
def regexp_count(str: ColumnOrName, regexp: ColumnOrName) -> Column: ...
def regexp_extract(str: ColumnOrName, pattern: str, idx: int) -> Column: ...
def regexp_extract_all(str: ColumnOrName, regexp: ColumnOrName, idx: int | Column | None = None) -> Column: ...
def regexp_replace(string: ColumnOrName, pattern: str | Column, replacement: str | Column) -> Column: ...
def regexp_substr(str: ColumnOrName, regexp: ColumnOrName) -> Column: ...
def regexp_instr(str: ColumnOrName, regexp: ColumnOrName, idx: int | Column | None = None) -> Column: ...
def initcap(col: ColumnOrName) -> Column: ...
def soundex(col: ColumnOrName) -> Column: ...
def length(col: ColumnOrName) -> Column: ...
def octet_length(col: ColumnOrName) -> Column: ...
def bit_length(col: ColumnOrName) -> Column: ...
def translate(srcCol: ColumnOrName, matching: str, replace: str) -> Column: ...
def to_binary(col: ColumnOrName, format: ColumnOrName | None = None) -> Column: ...
def to_char(col: ColumnOrName, format: ColumnOrName) -> Column: ...
def to_varchar(col: ColumnOrName, format: ColumnOrName) -> Column: ...
def to_number(col: ColumnOrName, format: ColumnOrName) -> Column: ...
def replace(src: ColumnOrName, search: ColumnOrName, replace: ColumnOrName | None = None) -> Column: ...
def split_part(src: ColumnOrName, delimiter: ColumnOrName, partNum: ColumnOrName) -> Column: ...
def substr(str: ColumnOrName, pos: ColumnOrName, len: ColumnOrName | None = None) -> Column: ...
def parse_url(url: ColumnOrName, partToExtract: ColumnOrName, key: ColumnOrName | None = None) -> Column: ...
def printf(format: ColumnOrName, *cols: ColumnOrName) -> Column: ...
def url_decode(str: ColumnOrName) -> Column: ...
def url_encode(str: ColumnOrName) -> Column: ...
def position(substr: ColumnOrName, str: ColumnOrName, start: ColumnOrName | None = None) -> Column: ...
def endswith(str: ColumnOrName, suffix: ColumnOrName) -> Column: ...
def startswith(str: ColumnOrName, prefix: ColumnOrName) -> Column: ...
def char(col: ColumnOrName) -> Column: ...
def try_to_binary(col: ColumnOrName, format: ColumnOrName | None = None) -> Column: ...
def try_to_number(col: ColumnOrName, format: ColumnOrName) -> Column: ...
def btrim(str: ColumnOrName, trim: ColumnOrName | None = None) -> Column: ...
def char_length(str: ColumnOrName) -> Column: ...
def character_length(str: ColumnOrName) -> Column: ...
def contains(left: ColumnOrName, right: ColumnOrName) -> Column: ...
def elt(*inputs: ColumnOrName) -> Column: ...
def find_in_set(str: ColumnOrName, str_array: ColumnOrName) -> Column: ...
def like(str: ColumnOrName, pattern: ColumnOrName, escapeChar: Column | None = None) -> Column: ...
def ilike(str: ColumnOrName, pattern: ColumnOrName, escapeChar: Column | None = None) -> Column: ...
def lcase(str: ColumnOrName) -> Column: ...
def ucase(str: ColumnOrName) -> Column: ...
def left(str: ColumnOrName, len: ColumnOrName) -> Column: ...
def right(str: ColumnOrName, len: ColumnOrName) -> Column: ...
def mask(col: ColumnOrName, upperChar: ColumnOrName | None = None, lowerChar: ColumnOrName | None = None, digitChar: ColumnOrName | None = None, otherChar: ColumnOrName | None = None) -> Column: ...
def curdate() -> Column: ...
def current_date() -> Column: ...
def current_timestamp() -> Column: ...
def now() -> Column: ...
def current_timezone() -> Column: ...
def localtimestamp() -> Column: ...
def date_format(date: ColumnOrName, format: str) -> Column: ...
def year(col: ColumnOrName) -> Column: ...
def quarter(col: ColumnOrName) -> Column: ...
def month(col: ColumnOrName) -> Column: ...
def dayofweek(col: ColumnOrName) -> Column: ...
def dayofmonth(col: ColumnOrName) -> Column: ...
def day(col: ColumnOrName) -> Column: ...
def dayofyear(col: ColumnOrName) -> Column: ...
def hour(col: ColumnOrName) -> Column: ...
def minute(col: ColumnOrName) -> Column: ...
def second(col: ColumnOrName) -> Column: ...
def weekofyear(col: ColumnOrName) -> Column: ...
def weekday(col: ColumnOrName) -> Column: ...
def extract(field: ColumnOrName, source: ColumnOrName) -> Column: ...
def date_part(field: ColumnOrName, source: ColumnOrName) -> Column: ...
def datepart(field: ColumnOrName, source: ColumnOrName) -> Column: ...
def make_date(year: ColumnOrName, month: ColumnOrName, day: ColumnOrName) -> Column: ...
def date_add(start: ColumnOrName, days: ColumnOrName | int) -> Column: ...
def dateadd(start: ColumnOrName, days: ColumnOrName | int) -> Column: ...
def date_sub(start: ColumnOrName, days: ColumnOrName | int) -> Column: ...
def datediff(end: ColumnOrName, start: ColumnOrName) -> Column: ...
def date_diff(end: ColumnOrName, start: ColumnOrName) -> Column: ...
def date_from_unix_date(days: ColumnOrName) -> Column: ...
def add_months(start: ColumnOrName, months: ColumnOrName | int) -> Column: ...
def months_between(date1: ColumnOrName, date2: ColumnOrName, roundOff: bool = True) -> Column: ...
def to_date(col: ColumnOrName, format: str | None = None) -> Column: ...
def unix_date(col: ColumnOrName) -> Column: ...
def unix_micros(col: ColumnOrName) -> Column: ...
def unix_millis(col: ColumnOrName) -> Column: ...
def unix_seconds(col: ColumnOrName) -> Column: ...
@overload
def to_timestamp(col: ColumnOrName) -> Column: ...
@overload
def to_timestamp(col: ColumnOrName, format: str) -> Column: ...
def try_to_timestamp(col: ColumnOrName, format: ColumnOrName | None = None) -> Column: ...
def xpath(xml: ColumnOrName, path: ColumnOrName) -> Column: ...
def xpath_boolean(xml: ColumnOrName, path: ColumnOrName) -> Column: ...
def xpath_double(xml: ColumnOrName, path: ColumnOrName) -> Column: ...
def xpath_number(xml: ColumnOrName, path: ColumnOrName) -> Column: ...
def xpath_float(xml: ColumnOrName, path: ColumnOrName) -> Column: ...
def xpath_int(xml: ColumnOrName, path: ColumnOrName) -> Column: ...
def xpath_long(xml: ColumnOrName, path: ColumnOrName) -> Column: ...
def xpath_short(xml: ColumnOrName, path: ColumnOrName) -> Column: ...
def xpath_string(xml: ColumnOrName, path: ColumnOrName) -> Column: ...
def trunc(date: ColumnOrName, format: str) -> Column: ...
def date_trunc(format: str, timestamp: ColumnOrName) -> Column: ...
def next_day(date: ColumnOrName, dayOfWeek: str) -> Column: ...
def last_day(date: ColumnOrName) -> Column: ...
def from_unixtime(timestamp: ColumnOrName, format: str = 'yyyy-MM-dd HH:mm:ss') -> Column: ...
@overload
def unix_timestamp(timestamp: ColumnOrName, format: str = ...) -> Column: ...
@overload
def unix_timestamp() -> Column: ...
def from_utc_timestamp(timestamp: ColumnOrName, tz: ColumnOrName) -> Column: ...
def to_utc_timestamp(timestamp: ColumnOrName, tz: ColumnOrName) -> Column: ...
def timestamp_seconds(col: ColumnOrName) -> Column: ...
def timestamp_millis(col: ColumnOrName) -> Column: ...
def timestamp_micros(col: ColumnOrName) -> Column: ...
def window(timeColumn: ColumnOrName, windowDuration: str, slideDuration: str | None = None, startTime: str | None = None) -> Column: ...
def window_time(windowColumn: ColumnOrName) -> Column: ...
def session_window(timeColumn: ColumnOrName, gapDuration: Column | str) -> Column: ...
def to_unix_timestamp(timestamp: ColumnOrName, format: ColumnOrName | None = None) -> Column: ...
def to_timestamp_ltz(timestamp: ColumnOrName, format: ColumnOrName | None = None) -> Column: ...
def to_timestamp_ntz(timestamp: ColumnOrName, format: ColumnOrName | None = None) -> Column: ...
def bucket(numBuckets: Column | int, col: ColumnOrName) -> Column: ...
def years(col: ColumnOrName) -> Column: ...
def months(col: ColumnOrName) -> Column: ...
def days(col: ColumnOrName) -> Column: ...
def hours(col: ColumnOrName) -> Column: ...
def convert_timezone(sourceTz: Column | None, targetTz: Column, sourceTs: ColumnOrName) -> Column: ...
def make_dt_interval(days: ColumnOrName | None = None, hours: ColumnOrName | None = None, mins: ColumnOrName | None = None, secs: ColumnOrName | None = None) -> Column: ...
def make_interval(years: ColumnOrName | None = None, months: ColumnOrName | None = None, weeks: ColumnOrName | None = None, days: ColumnOrName | None = None, hours: ColumnOrName | None = None, mins: ColumnOrName | None = None, secs: ColumnOrName | None = None) -> Column: ...
def make_timestamp(years: ColumnOrName, months: ColumnOrName, days: ColumnOrName, hours: ColumnOrName, mins: ColumnOrName, secs: ColumnOrName, timezone: ColumnOrName | None = None) -> Column: ...
def make_timestamp_ltz(years: ColumnOrName, months: ColumnOrName, days: ColumnOrName, hours: ColumnOrName, mins: ColumnOrName, secs: ColumnOrName, timezone: ColumnOrName | None = None) -> Column: ...
def make_timestamp_ntz(years: ColumnOrName, months: ColumnOrName, days: ColumnOrName, hours: ColumnOrName, mins: ColumnOrName, secs: ColumnOrName) -> Column: ...
def make_ym_interval(years: ColumnOrName | None = None, months: ColumnOrName | None = None) -> Column: ...
def current_catalog() -> Column: ...
def current_database() -> Column: ...
def current_schema() -> Column: ...
def current_user() -> Column: ...
def user() -> Column: ...
def assert_true(col: ColumnOrName, errMsg: Column | str | None = None) -> Column: ...
def raise_error(errMsg: Column | str) -> Column: ...
def crc32(col: ColumnOrName) -> Column: ...
def hash(*cols: ColumnOrName) -> Column: ...
def xxhash64(*cols: ColumnOrName) -> Column: ...
def md5(col: ColumnOrName) -> Column: ...
def sha1(col: ColumnOrName) -> Column: ...
def sha2(col: ColumnOrName, numBits: int) -> Column: ...
def hll_sketch_agg(col: ColumnOrName, lgConfigK: int | Column | None = None) -> Column: ...
def hll_union_agg(col: ColumnOrName, allowDifferentLgConfigK: bool | None = None) -> Column: ...
def hll_sketch_estimate(col: ColumnOrName) -> Column: ...
def hll_union(col1: ColumnOrName, col2: ColumnOrName, allowDifferentLgConfigK: bool | None = None) -> Column: ...
def ifnull(col1: ColumnOrName, col2: ColumnOrName) -> Column: ...
def isnotnull(col: ColumnOrName) -> Column: ...
def equal_null(col1: ColumnOrName, col2: ColumnOrName) -> Column: ...
def nullif(col1: ColumnOrName, col2: ColumnOrName) -> Column: ...
def nvl(col1: ColumnOrName, col2: ColumnOrName) -> Column: ...
def nvl2(col1: ColumnOrName, col2: ColumnOrName, col3: ColumnOrName) -> Column: ...
def aes_encrypt(input: ColumnOrName, key: ColumnOrName, mode: ColumnOrName | None = None, padding: ColumnOrName | None = None, iv: ColumnOrName | None = None, aad: ColumnOrName | None = None) -> Column: ...
def aes_decrypt(input: ColumnOrName, key: ColumnOrName, mode: ColumnOrName | None = None, padding: ColumnOrName | None = None, aad: ColumnOrName | None = None) -> Column: ...
def try_aes_decrypt(input: ColumnOrName, key: ColumnOrName, mode: ColumnOrName | None = None, padding: ColumnOrName | None = None, aad: ColumnOrName | None = None) -> Column: ...
def sha(col: ColumnOrName) -> Column: ...
def input_file_block_length() -> Column: ...
def input_file_block_start() -> Column: ...
def reflect(*cols: ColumnOrName) -> Column: ...
def java_method(*cols: ColumnOrName) -> Column: ...
def version() -> Column: ...
def typeof(col: ColumnOrName) -> Column: ...
def stack(*cols: ColumnOrName) -> Column: ...
def bitmap_bit_position(col: ColumnOrName) -> Column: ...
def bitmap_bucket_number(col: ColumnOrName) -> Column: ...
def bitmap_construct_agg(col: ColumnOrName) -> Column: ...
def bitmap_count(col: ColumnOrName) -> Column: ...
def bitmap_or_agg(col: ColumnOrName) -> Column: ...
def call_udf(udfName: str, *cols: ColumnOrName) -> Column: ...
def unwrap_udt(col: ColumnOrName) -> Column: ...
def udf(f: Callable[..., Any] | DataTypeOrString | None = None, returnType: DataTypeOrString = ..., useArrow: bool | None = None) -> UserDefinedFunctionLike | Callable[[Callable[..., Any]], 'UserDefinedFunctionLike']: ...
def udtf(cls: Incomplete | None = None, *, returnType: StructType | str, useArrow: bool | None = None) -> UserDefinedTableFunction | Callable[[type], 'UserDefinedTableFunction']: ...
def call_function(funcName: str, *cols: ColumnOrName) -> Column: ...

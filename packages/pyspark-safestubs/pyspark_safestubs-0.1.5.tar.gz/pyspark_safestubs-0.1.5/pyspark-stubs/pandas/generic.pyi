import numpy as np
import pandas as pd
from abc import ABCMeta, abstractmethod
from pyspark.pandas._typing import Axis as Axis, DataFrameOrSeries as DataFrameOrSeries, Dtype as Dtype, FrameLike as FrameLike, Label as Label, Name as Name, Scalar as Scalar
from pyspark.pandas.frame import DataFrame as DataFrame
from pyspark.pandas.groupby import GroupBy as GroupBy
from pyspark.pandas.indexes.base import Index as Index
from pyspark.pandas.indexing import AtIndexer as AtIndexer, LocIndexer as LocIndexer, iAtIndexer as iAtIndexer, iLocIndexer as iLocIndexer
from pyspark.pandas.internal import InternalFrame as InternalFrame
from pyspark.pandas.series import Series as Series
from pyspark.pandas.typedef import spark_type_to_pandas_dtype as spark_type_to_pandas_dtype
from pyspark.pandas.utils import SPARK_CONF_ARROW_ENABLED as SPARK_CONF_ARROW_ENABLED, is_name_like_tuple as is_name_like_tuple, is_name_like_value as is_name_like_value, log_advice as log_advice, name_like_string as name_like_string, scol_for as scol_for, sql_conf as sql_conf, validate_arguments_and_invoke_function as validate_arguments_and_invoke_function, validate_axis as validate_axis, validate_mode as validate_mode
from pyspark.pandas.window import Expanding as Expanding, ExponentialMoving as ExponentialMoving, Rolling as Rolling
from pyspark.sql import Column as Column
from pyspark.sql.types import BooleanType as BooleanType, DoubleType as DoubleType, LongType as LongType, NumericType as NumericType
from typing import Any, Callable, IO, NoReturn

bool_type = bool

class Frame(metaclass=ABCMeta):
    @abstractmethod
    def __getitem__(self, key: Any) -> Any: ...
    @property
    @abstractmethod
    def dtypes(self) -> pd.Series | Dtype: ...
    @abstractmethod
    def to_pandas(self) -> pd.DataFrame | pd.Series: ...
    @property
    @abstractmethod
    def index(self) -> Index: ...
    @abstractmethod
    def copy(self) -> FrameLike: ...
    @abstractmethod
    def head(self, n: int = 5) -> FrameLike: ...
    def cummin(self, skipna: bool = True) -> FrameLike: ...
    def cummax(self, skipna: bool = True) -> FrameLike: ...
    def cumsum(self, skipna: bool = True) -> FrameLike: ...
    def cumprod(self, skipna: bool = True) -> FrameLike: ...
    def get_dtype_counts(self) -> pd.Series: ...
    def pipe(self, func: Callable[..., Any], *args: Any, **kwargs: Any) -> Any: ...
    def to_numpy(self) -> np.ndarray: ...
    @property
    def values(self) -> np.ndarray: ...
    def to_csv(self, path: str | None = None, sep: str = ',', na_rep: str = '', columns: list[Name] | None = None, header: bool = True, quotechar: str = '"', date_format: str | None = None, escapechar: str | None = None, num_files: int | None = None, mode: str = 'w', partition_cols: str | list[str] | None = None, index_col: str | list[str] | None = None, **options: Any) -> str | None: ...
    def to_json(self, path: str | None = None, compression: str = 'uncompressed', num_files: int | None = None, mode: str = 'w', orient: str = 'records', lines: bool = True, partition_cols: str | list[str] | None = None, index_col: str | list[str] | None = None, **options: Any) -> str | None: ...
    def to_excel(self, excel_writer: str | pd.ExcelWriter, sheet_name: str = 'Sheet1', na_rep: str = '', float_format: str | None = None, columns: str | list[str] | None = None, header: bool = True, index: bool = True, index_label: str | list[str] | None = None, startrow: int = 0, startcol: int = 0, engine: str | None = None, merge_cells: bool = True, encoding: str | None = None, inf_rep: str = 'inf', verbose: bool = True, freeze_panes: tuple[int, int] | None = None) -> None: ...
    def mean(self, axis: Axis | None = None, skipna: bool = True, numeric_only: bool = None) -> Scalar | Series: ...
    def sum(self, axis: Axis | None = None, skipna: bool = True, numeric_only: bool = None, min_count: int = 0) -> Scalar | Series: ...
    def product(self, axis: Axis | None = None, skipna: bool = True, numeric_only: bool = None, min_count: int = 0) -> Scalar | Series: ...
    prod = product
    def skew(self, axis: Axis | None = None, skipna: bool = True, numeric_only: bool = None) -> Scalar | Series: ...
    def kurtosis(self, axis: Axis | None = None, skipna: bool = True, numeric_only: bool = None) -> Scalar | Series: ...
    kurt = kurtosis
    def min(self, axis: Axis | None = None, skipna: bool = True, numeric_only: bool = None) -> Scalar | Series: ...
    def max(self, axis: Axis | None = None, skipna: bool = True, numeric_only: bool = None) -> Scalar | Series: ...
    def count(self, axis: Axis | None = None, numeric_only: bool = False) -> Scalar | Series: ...
    def std(self, axis: Axis | None = None, skipna: bool = True, ddof: int = 1, numeric_only: bool = None) -> Scalar | Series: ...
    def var(self, axis: Axis | None = None, ddof: int = 1, numeric_only: bool = None) -> Scalar | Series: ...
    def median(self, axis: Axis | None = None, skipna: bool = True, numeric_only: bool = None, accuracy: int = 10000) -> Scalar | Series: ...
    def sem(self, axis: Axis | None = None, skipna: bool = True, ddof: int = 1, numeric_only: bool = None) -> Scalar | Series: ...
    @property
    def size(self) -> int: ...
    def abs(self) -> FrameLike: ...
    def groupby(self, by: Name | Series | list[Name | Series], axis: Axis = 0, as_index: bool = True, dropna: bool = True) -> GroupBy[FrameLike]: ...
    def bool(self) -> bool: ...
    def first_valid_index(self) -> Scalar | tuple[Scalar, ...] | None: ...
    def last_valid_index(self) -> Scalar | tuple[Scalar, ...] | None: ...
    def rolling(self, window: int, min_periods: int | None = None) -> Rolling[FrameLike]: ...
    def expanding(self, min_periods: int = 1) -> Expanding[FrameLike]: ...
    def ewm(self, com: float | None = None, span: float | None = None, halflife: float | None = None, alpha: float | None = None, min_periods: int | None = None, ignore_na: bool_type = False) -> ExponentialMoving[FrameLike]: ...
    def get(self, key: Any, default: Any | None = None) -> Any: ...
    def squeeze(self, axis: Axis | None = None) -> Scalar | DataFrame | Series: ...
    def truncate(self, before: Any | None = None, after: Any | None = None, axis: Axis | None = None, copy: bool_type = True) -> DataFrameOrSeries: ...
    def to_markdown(self, buf: IO[str] | str | None = None, mode: str | None = None) -> str: ...
    @abstractmethod
    def fillna(self, value: Any | None = None, method: str | None = None, axis: Axis | None = None, inplace: bool_type = False, limit: int | None = None) -> FrameLike: ...
    def bfill(self, axis: Axis | None = None, inplace: bool_type = False, limit: int | None = None) -> FrameLike: ...
    backfill = bfill
    def ffill(self, axis: Axis | None = None, inplace: bool_type = False, limit: int | None = None) -> FrameLike: ...
    pad = ffill
    def interpolate(self, method: str = 'linear', limit: int | None = None, limit_direction: str | None = None, limit_area: str | None = None) -> FrameLike: ...
    @property
    def at(self) -> AtIndexer: ...
    @property
    def iat(self) -> iAtIndexer: ...
    @property
    def iloc(self) -> iLocIndexer: ...
    @property
    def loc(self) -> LocIndexer: ...
    def __bool__(self) -> NoReturn: ...
